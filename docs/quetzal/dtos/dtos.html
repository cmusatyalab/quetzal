<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>quetzal.dtos.dtos API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>quetzal.dtos.dtos</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import importlib
import logging
import os
import shutil

from enum import Enum
from pathlib import Path
from typing import NewType, Optional, TypeAlias, Union

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
debug = lambda *args: logger.debug(&#34; &#34;.join([str(arg) for arg in args]))

EXAMPLE_INFO = &#34;&#34;&#34;Route: army-demo
Recorded Date (MM/DD/YYYY): 10/5/2023
Uploader: Admin
Weather Condition: Sunny, Green
Description: Recorded by Mihir and Thom&#34;&#34;&#34;

META_SUFFIX = &#34;.meta.txt&#34;
INFO_SUFFIX = &#34;.info.txt&#34;
ADMIN_ID = &#34;admin&#34;
UserId = NewType(&#34;UserId&#34;, str)

class User:
    &#34;&#34;&#34;Represents a user, identified by a unique identifier.&#34;&#34;&#34;
    GuestId = None

    def __init__(self, id: Union[UserId, &#34;User&#34;] = None):
        &#34;&#34;&#34;Initializes a User instance.
        
        Args:
            id (Optional[UserId]): The unique identifier for the user. Defaults to None, representing a guest.
        &#34;&#34;&#34;
        match id:
            case User() as user:
                self._id = user._id
            case _:
                self._id = id if id else User.GuestId

    @property
    def id(self) -&gt; UserId:
        &#34;&#34;&#34;Gets the user&#39;s unique identifier.&#34;&#34;&#34;
        return self._id

    @id.setter
    def id(self, value):
        &#34;&#34;&#34;Sets the user&#39;s unique identifier.&#34;&#34;&#34;
        self._id = value

    def __eq__(self, other):
        &#34;&#34;&#34;Checks equality with another User instance or a string id.&#34;&#34;&#34;
        match other:
            case User():
                return self._id == other._id
            case str():
                return self._id == other
            case _:
                return NotImplemented

    def __repr__(self):
        &#34;&#34;&#34;Represents the User instance as a string.&#34;&#34;&#34;
        match self._id:
            case User.GuestId:
                return &#34;Guest&#34;
            case _:
                return f&#34;&lt;User: {str(self._id)}&gt;&#34;

class Permission(Enum):
    &#34;&#34;&#34;Defines access permissions for files.&#34;&#34;&#34;
    READ_ONLY = &#34;read_only&#34;
    POST_ONLY = &#34;post_only&#34;
    FULL_WRITE = &#34;full_write&#34;


class Visibility(Enum):
    &#34;&#34;&#34;Defines visibility settings for files.&#34;&#34;&#34;
    SHARED = &#34;shared&#34;
    PRIVATE = &#34;private&#34;


class FileType(Enum):
    &#34;&#34;&#34;Defines the type of a file system object.&#34;&#34;&#34;
    FILE = &#34;file&#34;
    DIRECTORY = &#34;directory&#34;


class AnalysisProgress(Enum):
    &#34;&#34;&#34;Represents the progress of analysis on a file.&#34;&#34;&#34;
    FULL = &#34;full&#34;
    HALF = &#34;half&#34;
    NONE = &#34;none&#34;

    def __eq__(self, other):
        if isinstance(other, AnalysisProgress):
            return self.value == other.value
        return NotImplemented

    def __lt__(self, other):
        if isinstance(other, AnalysisProgress):
            return self.value &gt; other.value
        return NotImplemented

    def __le__(self, other):
        if isinstance(other, AnalysisProgress):
            return self.value &gt;= other.value
        return NotImplemented

    def __gt__(self, other):
        if isinstance(other, AnalysisProgress):
            return self.value &lt; other.value
        return NotImplemented

    def __ge__(self, other):
        if isinstance(other, AnalysisProgress):
            return self.value &lt;= other.value
        return NotImplemented

    def __hash__(self):
        return hash(self.value)


CreatedBy = NewType(&#34;CreatedBy&#34;, User)
SpecificType = NewType(&#34;SpecificType&#34;, str)
MetaData: TypeAlias = Union[
    Permission, Visibility, FileType, AnalysisProgress, CreatedBy, SpecificType
]

class Action(Enum):
    &#34;&#34;&#34;Defines possible actions that can be performed on files.&#34;&#34;&#34;
    NEW_DIR = &#34;new_dir&#34;
    UPLOAD_FILE = &#34;upload_file&#34;
    RENAME = &#34;rename&#34;
    SHARE = &#34;share&#34;
    DELETE = &#34;delete&#34;
    DOWNLOAD = &#34;download&#34;
    ANALYZE = &#34;analyze&#34;
    EDIT = &#34;edit&#34;
    COPY = &#34;copy&#34;
    MOVE = &#34;move&#34;
    # WAIT = &#34;wait&#34;


class AccessMode(Enum):
    &#34;&#34;&#34;Defines access modes based on user relation to the file.&#34;&#34;&#34;
    OTHERS = &#34;others&#34;
    OWNER = &#34;owner&#34;


def appendText(path: Path, text: str) -&gt; Path:
    &#34;&#34;&#34;Appends text to the file name, before the file extension.

    Args:
        path (Path): The original file path.
        text (str): The text to append.

    Returns:
        Path: The new file path with the text appended.
    &#34;&#34;&#34;
    return path.with_name(path.stem + text + path.suffix)


def getCopyName(path: Path) -&gt; Path:
    &#34;&#34;&#34;The function iteratively appends &#39;_copy&#39; to the base name, before the file extension, of the provided path
    until a non-existing path is generated.

    Args:
        path: A Path object representing the original file or directory.

    Returns:
        A Path object representing the new, unique path with &#39;_copy&#39; appended.
    &#34;&#34;&#34;
    while path.exists():
        path = appendText(path, &#34;_copy&#34;)
    return path


DATABASE_ROOT = &#34;database&#34;
QUERY_ROOT = &#34;query&#34;

reserved_names = [DATABASE_ROOT, QUERY_ROOT]


class QuetzalFile:
    &#34;&#34;&#34;
    Represents a file or directory within the Quetzal file system, facilitating operations such as creation,
    renaming, sharing, and metadata management. This class serves as a base for specialized file types within Quetzal,
    providing a structured approach to handle common file-related tasks.

    Subclasses of `QuetzalFile` may implement custom behaviors for specific operations (e.g., copying, analyzing,
    sharing) by overriding the internal methods designed for these purposes. For example, see the `Video` class
    for implementations that tailor these operations to the needs of video file management within Quetzal.
    &#34;&#34;&#34;
    
    FILE_DEFAULT_DESCRIPTION = &#34;Uploader::= default\nRecorded Date (MM/DD/YYYY)::= default\nTime-of-day::= default\nWeather Condition::= default\nDescription::= default&#34;
    PROJECT_DEFAULT_DESCRIPTION = &#34;Route Location::= default\nLast Update (MM/DD/YYYY)::= default\nLast Edit by::= default\nDescription::= default&#34;
    FILE_DEFAULT_META = &#34;FileType::= file\nVisibility::= private\nPermission::= full_write\nAnalysisProgress::= none\nSpecificType::= Video\n&#34;
    PROJECT_DEFAULT_META = (
        &#34;FileType::= directory\nVisibility::= private\nPermission::= full_write\n&#34;
    )
    USER_ROOT_META = (
        &#34;FileType::= directory\nVisibility::= shared\nPermission::= read_only\n&#34;
    )
    USER_ROOT_DESCRIPTION = &#34;Description::=root directory for &#34;
    ROOT_META = &#34;FileType::= directory\nVisibility::= shared\nPermission::= read_only\nCreatedBy::= admin\nOwner::= admin&#34;
    ROOT_DESCRIPTOIN = &#34;Description::=database root&#34;
    

    def __init__(
        self,
        path: Union[str, Path],  # path to the dir/file from root_dir
        root_dir: Union[str, Path],
        metadata_dir: Union[str, Path],
        user: Union[str, User] = User.GuestId,
        home: Union[str, Path] = &#34;./&#34;,
        metadata: Optional[dict[str, MetaData]] = None,
        parent: &#39;QuetzalFile&#39; = None,
    ):
        &#34;&#34;&#34;        
        Args:
            path (Path): The path of the file or directory, relative to the root directory.
            root_dir (Path): The root directory path of the Quetzal file system.
            metadata_dir (Path): The directory path where metadata files are stored.
            user (User): The user who is interacting with the file.
            home (Path): The base home directory path (relative to rood directory). Defaults to &#34;./&#34;.
            metadata (Optional[Dict[str, MetaData]]): The metadata associated with the file.
            parent (Optional[QuetzalFile]): The parent directory of the current file.
        &#34;&#34;&#34;
        self._path = Path(path)
        self._root_dir = Path(root_dir)
        self._metadata_dir = Path(metadata_dir)
        self._user = User(user)
        self._home = Path(home)
        self._parent = parent

        assert self._user != &#34;example&#34;

        if not (self.full_path).exists():
            if self._path == Path(self._user.id):
                os.makedirs(self.full_path, exist_ok=True)
                info_path = self.getDescriptionPath(self._path)
                info_path.write_text(self.USER_ROOT_DESCRIPTION)
                mata_path = self.getMetaDataPath(self._path)
                mata_path.write_text(self.USER_ROOT_META + &#34;CreatedBy::= admin\n&#34; )
            else:    
                raise FileNotFoundError(
                    f&#39;File &#34;{self._root_dir / self._path}&#34; Do not Exist&#39;
                )

        if not self.getMetaDataPath(self._path).exists():
            raise FileNotFoundError(
                f&#39;Meta File &#34;{self.getMetaDataPath(self._path)}&#34; Do not Exist&#39;
            )

        if not self._path.is_relative_to(self._home):
            raise ValueError(f&#39;&#34;{path}&#34; is not relative to &#34;{home}&#34;&#39;)

        ## load_metadata
        self._parseMetadata(metadata)

        match self._path.parts:
            case [user_id, *_]:
                self._owner = User(user_id)
            case _:
                self._owner = User(ADMIN_ID)

        self._mode = (
            AccessMode.OWNER if self._owner == self._user else AccessMode.OTHERS
        )
        
        self._iterdir = None

    def __hash__(self):
        return hash(str(self.path))

    def __eq__(self, other):
        match other:
            case QuetzalFile():
                return self._path == other._path
            case str():
                return self._path == other
            case _:
                return NotImplemented

    @property
    def _abs_path(self) -&gt; Path:
        &#34;&#34;&#34;Full absolute path of the file&#34;&#34;&#34;
        return (self._root_dir / self._path).absolute()

    @property
    def path(self) -&gt; Path:
        &#34;&#34;&#34;Relative path to the file or directory from the &#34;home&#34; directory.&#34;&#34;&#34;
        return self._path.relative_to(self._home)

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;The name of the file or directory.&#34;&#34;&#34;
        return self._path.name

    @property
    def type(self) -&gt; FileType:
        &#34;&#34;&#34;The type of the file, either FILE or DIRECTORY.&#34;&#34;&#34;
        return self._type

    @property
    def full_path(self) -&gt; Path:
        &#34;&#34;&#34;The full filesystem path to the file or directory.&#34;&#34;&#34;
        return self._root_dir / self._path

    @property
    def analysis_progress(self) -&gt; AnalysisProgress:
        &#34;&#34;&#34;The current progress of any ongoing analysis.&#34;&#34;&#34;
        return self._analysis_progress

    @property
    def visibility(self) -&gt; Visibility:
        &#34;&#34;&#34;The visibility setting of the file, either SHARED or PRIVATE.&#34;&#34;&#34;
        return self._visibility

    @property
    def permission(self) -&gt; Permission:
        &#34;&#34;&#34;The access permissions of the file.&#34;&#34;&#34;
        return self._permission

    @property
    def createdBy(self) -&gt; User:
        &#34;&#34;&#34;The user who created the file.&#34;&#34;&#34;
        return self._created_by.id

    @property
    def user(self) -&gt; User:
        &#34;&#34;&#34;The current user interacting with the file.&#34;&#34;&#34;
        return self._user.id

    @property
    def home(self) -&gt; Path:
        &#34;&#34;&#34;The base home directory path.&#34;&#34;&#34;
        return self._home

    @property
    def mode(self) -&gt; AccessMode:
        &#34;&#34;&#34;The access mode, indicating if the current user is the OWNER or OTHERS.&#34;&#34;&#34;
        return self._mode

    @staticmethod
    def fromFile(file: &#34;QuetzalFile&#34;, path: Union[str, Path], home: Optional[Union[str, Path]]=None) -&gt; &#34;QuetzalFile&#34;:
        &#34;&#34;&#34;
        Creates a new instance of QuetzalFile based on an existing instance.

        Args:
            file: The QuetzalFile instance to base the new instance on.
            path: The path for the new QuetzalFile instance. Actual path relative to the root_dir will be &#34;./home/path&#34;.
            home: The home directory for the new instance. If None, the home of the &#39;file&#39; is used.

        Returns:
            A new QuetzalFile instance based on the provided file and path.
        &#34;&#34;&#34;
        
        if home is None:    
            home = file._home
        else:
            home = Path(home)
        return QuetzalFile(
            path=home / path,
            root_dir=file._root_dir,
            metadata_dir=file._metadata_dir,
            user=file._user,
            home=home
        )

    def loadMetaData(self, file: Union[str, Path]) -&gt; dict[str, MetaData]:
        &#34;&#34;&#34;
        Loads and returns the metadata for the specified file.
        &#34;&#34;&#34;
        metadata_path = self.getMetaDataPath(file)
        return self._loadMetaData(metadata_path)
    
    def iterdir(
        self,
        sharedOnly=False,
        directoryOnly=False,
    ) -&gt; list[&#34;QuetzalFile&#34;]:
        &#34;&#34;&#34;
        Lists the contents of the directory represented by this QuetzalFile.

        Args:
            sharedOnly: If True, only shared files/directories are listed.
            directoryOnly: If True, only directories are listed.

        Returns:
            A list of QuetzalFile objects representing the contents of the directory.
        &#34;&#34;&#34;
        
        assert self._type == FileType.DIRECTORY
        
        if self._iterdir:
            return self._iterdir

        directories = []
        files = []
        directory_path = self._root_dir / self._path

        sorted_items = sorted(directory_path.iterdir(), key=lambda x: x.stem.lower())
        for item in sorted_items:
            # Load MetaData of the file
            try:
                metadata = self.loadMetaData(item.relative_to(self._root_dir))
            except:
                continue

            # Filter Only Directory
            isdir = metadata[&#34;FileType&#34;] == FileType.DIRECTORY
            if directoryOnly and not isdir:
                continue

            # Filter only shared
            if sharedOnly and metadata[&#34;Visibility&#34;] != Visibility.SHARED:
                continue
            
            file = QuetzalFile._instantiateFile(
                path=item.relative_to(self._root_dir),
                root_dir=self._root_dir,
                metadata_dir=self._metadata_dir,
                user=self._user,
                home=self._home,
                metadata=metadata,
                parent=self,
            )

            # Sort to have directory first
            if isdir:
                directories.append(file)
            else:
                files.append(file)

        self._iterdir = directories + files
        return self._iterdir

    def perform(self, action: Action, input: dict):
        &#34;&#34;&#34;
        Performs the specified &#34;Action&#34; on this QuetzalFile object.

        Args:
            action: The action to perform, as defined by the Action enum.
            input: A dictionary containing the input parameters required for the action.

        Returns:
            A string message indicating the outcome of the action, or None if no action was performed.
        &#34;&#34;&#34;
        
        self._iterdir = None
        if self._parent:
            self._parent._iterdir = None
        match action:
            case Action.NEW_DIR:
                return self._newDirectory(**input)
            case Action.UPLOAD_FILE:
                return self._upload(**input)
            case Action.RENAME:
                return self._rename(**input)
            case Action.SHARE:
                return self._share(**input)
            case Action.DELETE:
                return self._delete(**input)
            case Action.ANALYZE:
                return self._analyze(**input)
            case Action.EDIT:
                return self._editDescription(**input)
            case Action.COPY:
                return self._copy(**input)
            case Action.MOVE:
                return self._move(**input)
            case _:
                raise NotImplemented(&#34;No Action Implemneted&#34;)
    
    @staticmethod
    def _instantiateFile(
        path: Path,
        root_dir: Path,
        metadata_dir: Path,
        user: User,
        home: Path,
        metadata: dict[str, MetaData],
        parent: &#39;QuetzalFile&#39;,
    ) -&gt; &#34;QuetzalFile&#34;:
        &#34;&#34;&#34;
        Instantiate a file into &#34;Specific Type&#34;, one of subclass of QuetzalFile.
        
        Args:
            path (Path): The path of the file or directory, relative to the root directory.
            root_dir (Path): The root directory path of the Quetzal file system.
            metadata_dir (Path): The directory path where metadata files are stored.
            user (User): The user who is interacting with the file.
            home (Path): The base home directory path (relative to rood directory). Defaults to &#34;./&#34;.
            metadata (Optional[Dict[str, MetaData]]): The metadata associated with the file.
            parent (Optional[QuetzalFile]): The parent directory of the current file.
        
        Returns:
            Instance of &#34;Specific Type&#34; (subclass of QuetzalFile)
        &#34;&#34;&#34;
        
        specific_file_class = None
        specific_type = metadata.get(&#34;SpecificType&#34;, None)
        
        if specific_type:
            module = importlib.import_module(f&#34;quetzal.dtos.{specific_type.lower()}&#34;)
            specific_file_class = getattr(module, specific_type)

        if specific_file_class and issubclass(specific_file_class, QuetzalFile):
            return specific_file_class(
                path=path,
                root_dir=root_dir,
                metadata_dir=metadata_dir,
                user=user,
                home=home,
                metadata=metadata,
                parent=parent,
            )
        else:
            return QuetzalFile(
                path=path,
                root_dir=root_dir,
                metadata_dir=metadata_dir,
                user=user,
                home=home,
                metadata=metadata,
                parent=parent
            )
            
    @staticmethod
    def _loadMetaData(metadata_path: Path) -&gt; dict[str, MetaData]:
        &#34;&#34;&#34;
        Load Queztalfile metadata from the given path
        
        Args:
            metadata_dir (Path): The directory path where metadata files are stored.
        
        Returns:
            dict[str, MetaData]
        &#34;&#34;&#34;
        if not os.path.exists(metadata_path):
            raise FileNotFoundError

        with open(metadata_path, &#34;r&#34;) as file:
            data = file.read().splitlines()
        metadata = {
            line.split(&#34;::=&#34;)[0].strip(): line.split(&#34;::=&#34;)[1].strip()
            for line in data
            if line.strip()
        }

        metadata[&#34;CreatedBy&#34;] = CreatedBy(User(metadata.get(&#34;CreatedBy&#34;, None)))
        metadata[&#34;FileType&#34;] = FileType(metadata.get(&#34;FileType&#34;, &#34;file&#34;))
        metadata[&#34;Visibility&#34;] = Visibility(metadata.get(&#34;Visibility&#34;, &#34;private&#34;))
        metadata[&#34;AnalysisProgress&#34;] = AnalysisProgress(
            metadata.get(&#34;AnalysisProgress&#34;, &#34;none&#34;)
        )
        metadata[&#34;Permission&#34;] = Permission(metadata.get(&#34;Permission&#34;, &#34;full_write&#34;))
        metadata[&#34;SpecificType&#34;] = SpecificType(metadata.get(&#34;SpecificType&#34;, None))

        return metadata

    def _parseMetadata(self, metadata: Optional[dict[str, MetaData]]):
        &#34;&#34;&#34;
        Assign Queztalfile metadata into attribute variables
        
        Args:
            metadata (Optional[dict[str, MetaData]]): metadata
        &#34;&#34;&#34;
        if metadata is None:
            metadata = self.loadMetaData(self._path)

        self._created_by = metadata[&#34;CreatedBy&#34;]
        self._type = metadata[&#34;FileType&#34;]
        self._visibility = metadata[&#34;Visibility&#34;]
        self._analysis_progress = metadata[&#34;AnalysisProgress&#34;]
        self._permission = metadata[&#34;Permission&#34;]

    
    
    def _updateMetaForRename(self, new_path: Union[str, Path]):
        &#34;&#34;&#34;
        Updates the metadata and description files&#39; paths for the current QuetzalFile
        instance to reflect a change in the file or directory&#39;s name (rename action).

        This method is invoked internally to handle the renaming of metadata and description
        files associated with the QuetzalFile, ensuring consistency within the filesystem.

        Args:
            new_path (Union[str, Path]): The new path (name) for the file or directory, reflecting the rename.
        &#34;&#34;&#34;
        orig_path_full = self._metadata_dir / self._path
        new_path_full = self._metadata_dir / new_path
        
        ## New Directory if needed
        if self._type == FileType.DIRECTORY:
            if orig_path_full.exists():
                os.rename(orig_path_full, new_path_full)
            
        ## Rename Metadata
        metadata_path = self._getMetaDataPath(orig_path_full)
        new_metadata_path = self._getMetaDataPath(new_path_full)
        if metadata_path.exists():
            os.rename(metadata_path, new_metadata_path)
        else:
            with open(new_metadata_path, &#34;w&#34;) as file:
                file.write(
                    self.PROJECT_DEFAULT_META
                    if self._type == FileType.DIRECTORY
                    else self.FILE_DEFAULT_META
                )

        ## Rename Description
        description_path = self._getDescriptionPath(orig_path_full)
        new_description_path = self._getDescriptionPath(new_path_full)
        if description_path.exists():
            os.rename(description_path, new_description_path)
        else:
            with open(new_description_path, &#34;w&#34;) as file:
                file.write(
                    self.PROJECT_DEFAULT_DESCRIPTION
                    if self._type == FileType.DIRECTORY
                    else self.FILE_DEFAULT_DESCRIPTION
                )
    
    
    def _rename(self, new_file_name: Union[str, Path]) -&gt; str:
        &#34;&#34;&#34;
        Renames the current QuetzalFile (file or directory) to the new specified name and updates
        the metadata accordingly.
        
        For given new_file_name, only the name of the file will be considered. Parent_name, and suffix of the name
        will be modified to match the original file.

        Args:
            new_file_name (Union[str, Path]): The new name for the file or directory.

        Returns:
            A confirmation message indicating the successful rename.
        &#34;&#34;&#34;
        
        new_file_name = Path(new_file_name)
        assert (
            self._mode == AccessMode.OWNER or self._permission == Permission.FULL_WRITE
        )
        assert new_file_name.stem not in reserved_names

        debug(f&#34;\n\n\t{self.name} called on rename {new_file_name}\n&#34;)

        # Validate suffix
        if new_file_name.suffix != self._path.suffix:
            new_file_name = Path(new_file_name.name + self._path.suffix)

        # Rename
        new_path = self._path.parent / new_file_name
        new_path_abs = self._root_dir / new_path
        if new_path_abs.exists():
            raise FileExistsError(
                f&#39;File/directory with name &#34;{new_file_name}&#34; already exist at the destination.&#39;
            )
        os.rename(self._abs_path, new_path_abs)
        self._updateMetaForRename(new_path=new_path)

        org_name = self.name
        self._path = new_path
        return f&#39;&#34;{org_name}&#34; renamed to &#34;{self.name}&#34;&#39;


    def _updateMetaForNewFile(
        self, target_path: Path, file_name: Path, meta_data: str, description: str, isDir: bool=False
    ):
        &#34;&#34;&#34;
        Creates and updates the metadata and description for a new file or directory
        that is being added to the filesystem.

        Args:
            target_path (Path): The target path where the new file or directory is located.
            file_name (Path): The name of the new file or directory.
            meta_data (str): The metadata to be written for the new file or directory.
            description (str): The description to be written for the new file or directory.
            isDir (bool): A flag indicating whether the new entity is a directory. Defaults to False.
        &#34;&#34;&#34;
        # Crate New Meta Data, Description, and Directory
        new_file_metadata = self._metadata_dir / target_path / file_name
        if isDir:
            os.makedirs(new_file_metadata, exist_ok=True)

        new_file_metadata_path = self._getMetaDataPath(new_file_metadata)
        with open(new_file_metadata_path, &#34;w&#34;) as file:
            file.write(meta_data)

        new_file_description_path = self._getDescriptionPath(new_file_metadata)
        with open(new_file_description_path, &#34;w&#34;) as file:
            file.write(description)


    def _newDirectory(self, dir_name: Union[str, Path]) -&gt; str:
        &#34;&#34;&#34;
        Creates a new directory under the current QuetzalFile path and updates the metadata and
        description for it.

        Args:
            dir_name (Union[str, Path]): The name of the new directory to create.

        Returns:
            A confirmation message indicating the successful creation of the directory.
        &#34;&#34;&#34;
        dir_name = Path(dir_name)
        assert (
            self._mode == AccessMode.OWNER or self._permission != Permission.READ_ONLY
        )
        assert self._type == FileType.DIRECTORY
        assert dir_name.stem not in reserved_names

        debug(f&#34;\n\n\t{self.name} called on New dir {dir_name}\n&#34;)
        
        new_dir_path = self._root_dir / self._path / dir_name
        if new_dir_path.exists():
            raise FileExistsError(
                f&#39;Directory with name &#34;{dir_name}&#34; already exist at the destination.&#39;
            )
        os.makedirs(new_dir_path, exist_ok=False)

        self._updateMetaForNewFile(
            self._path,
            dir_name,
            self.PROJECT_DEFAULT_META + &#34;CreatedBy::= &#34; + self._user.id + &#34;\n&#34;,
            self.PROJECT_DEFAULT_DESCRIPTION,
            isDir=True
        )

        return f&#39;&#34;{dir_name}&#34; Created&#39;
    

    def _upload(self, uploaded_files: Union[str, Path]) -&gt; str:
        &#34;&#34;&#34;
        Uploads and saves the specified files to the current QuetzalFile directory, updating
        the metadata for each uploaded file.
        
        The method should fail when called on QuetzalFile with &#34;File&#34; filetype.

        Args:
            uploaded_files (Union[str, Path]): The files to be uploaded.

        Returns:
            A confirmation message indicating the number of files successfully uploaded.
        &#34;&#34;&#34;
        assert self._mode == AccessMode.OWNER or self._permission != Permission.READ_ONLY
        assert self._type == FileType.DIRECTORY
        
        for uploaded_file in uploaded_files:
            assert Path(uploaded_file.name).stem not in reserved_names
            debug(f&#34;\n\n\t{self.name} called on upload {uploaded_file.name}\n&#34;)

            dest: Path = self._root_dir / self._path / uploaded_file.name
            orig_name = dest
            start_num = 0
            while dest.exists():
                dest = appendText(orig_name, f&#34;_{start_num}&#34;)
                start_num += 1

            with open(dest, mode=&#34;wb&#34;) as w:
                w.write(uploaded_file.getvalue())

            self._updateMetaForNewFile(
                self._path,
                dest.name,
                self.FILE_DEFAULT_META + &#34;CreatedBy::= &#34; + self._user.id + &#34;\n&#34;,
                self.FILE_DEFAULT_DESCRIPTION,
            )

        return f&#34;{len(uploaded_files)} files successfully uploaded&#34;


    def _updateMetaForShare(self, shared: Visibility, permission: Permission):
        &#34;&#34;&#34;
        Updates the metadata for the QuetzalFile (file or directory) to reflect new sharing settings,
        including visibility and permissions.

        Args:
            shared (Visibility): The new visibility setting for the file or directory.
            permission (Permission): The new permission setting for the file or directory.
        &#34;&#34;&#34;
        metadata_path = self.getMetaDataPath(self._path)
        if os.path.exists(metadata_path):
            with open(metadata_path, &#34;r+&#34;) as file:
                metadata = file.read()
                metadata = metadata.replace(
                    f&#34;Visibility::= {self._visibility.value}&#34;,
                    f&#34;Visibility::= {shared.value}&#34;,
                )
                metadata = metadata.replace(
                    f&#34;Permission::= {self._permission.value}&#34;,
                    f&#34;Permission::= {permission.value}&#34;,
                )
                file.seek(0)
                file.write(metadata)
                file.truncate()

        self._visibility = shared
        self._permission = permission


    def _share(self, shared: Visibility, permission: Permission) -&gt; str:
        &#34;&#34;&#34;
        Applies new sharing settings to the file or directory, affecting its visibility
        and access permissions, and updates the metadata accordingly.

        Args:
            shared (Visibility): The new visibility setting.
            permission (Permission): The new access permission setting.

        Returns:
            A confirmation message indicating the updated sharing settings.
        &#34;&#34;&#34;
        assert (
            self._mode == AccessMode.OWNER or self._permission == Permission.FULL_WRITE
        )

        if shared == self._visibility and permission == self._permission:
            return None

        debug(f&#34;\n\n\t{self.name} called on share {shared}:{permission}\n&#34;)

        self._updateMetaForShare(shared, permission)

        # If the QuetzalFile is a directory, apply the changes to all sub-projects and video files
        if self._type == FileType.DIRECTORY:
            for subfile in self.iterdir():
                subfile._updateMetaForShare(shared, permission)

        return f&#39;&#34;{self.name}&#34; Sharing Setting Updated&#39;

    def _updateMetaForDelete(self):
        &#34;&#34;&#34;
        Cleans up the metadata and description files associated with the file or directory
        that is being deleted.
        &#34;&#34;&#34;
        orig_path_full = self._metadata_dir / self._path
        metadata_path = self._getMetaDataPath(orig_path_full)
        description_path = self._getDescriptionPath(orig_path_full)

        if metadata_path.exists():
            os.remove(metadata_path)
        if description_path.exists():
            os.remove(description_path)
        if orig_path_full.exists():
            shutil.rmtree(orig_path_full)

    def _delete(self) -&gt; str:
        &#34;&#34;&#34;
        Deletes the current file or directory and cleans up its associated metadata
        and description files.

        Returns:
            A confirmation message indicating the successful deletion.
        &#34;&#34;&#34;
        assert (
            self._mode == AccessMode.OWNER or self._permission == Permission.FULL_WRITE
        )

        debug(f&#34;\n\n\t{self.name} called on delete\n&#34;)

        if self._type == FileType.FILE:
            os.remove(self._root_dir / self._path)
        else:  # For directories
            shutil.rmtree(self._root_dir / self._path)

        self._updateMetaForDelete()

        return f&#39;&#34;{self.name}&#34; Deleted&#39;

    def _updateMetaForAnalyze(self, new_progress: AnalysisProgress):
        &#34;&#34;&#34;
        Updates the metadata for the file to reflect a new state of analysis progress.

        Args:
            new_progress (AnalysisProgress): The new analysis progress state to update the metadata with.
        &#34;&#34;&#34;
        
        orig_path_full = self._metadata_dir / self._path
        metadata_path = self._getMetaDataPath(orig_path_full)

        if os.path.exists(metadata_path):
            with open(metadata_path, &#34;r+&#34;) as file:
                metadata = file.read()
                metadata = metadata.replace(
                    f&#34;AnalysisProgress::= {self._analysis_progress.value}&#34;,
                    f&#34;AnalysisProgress::= {new_progress.value}&#34;,
                )
                file.seek(0)
                file.write(metadata)
                file.truncate()

    def _syncAnalysisState(self):
        &#34;&#34;&#34;
        Synchronizes the analysis state of the file with the current status in the
        analysis engine or database, updating the metadata as necessary.
        &#34;&#34;&#34;
        assert self._type == FileType.FILE
        
        return

    def _analyze(self, option: AnalysisProgress, engine=None, device=None) -&gt; str:
        &#34;&#34;&#34;
        Initiat es analysis of the video file with the specified options, using the
        given analysis engine and device.

        Args:
            option (AnalysisProgress): The desired level of analysis to be performed.
            engine: The analysis engine to use for the analysis. Defaults to None.
            device: The cuda device to perform the analysis on. Defaults to None.

        Returns:
            A confirmation message indicating the completion of the analysis.
        &#34;&#34;&#34;     
        
        assert (
            self._mode == AccessMode.OWNER or self._permission != Permission.READ_ONLY
        )
        debug(f&#34;\n\t{self.name} called on analyze {option}\n&#34;)

        if option == None:
            return None

        return f&#39;&#34;{self.name}&#34; Analysis Done&#39;


    def _editDescription(self, value: str) -&gt; str:
        &#34;&#34;&#34;
        Updates the description for the file or directory with the given value.

        Args:
            value (str): The new description to be applied to the file or directory.

        Returns:
            A confirmation message indicating the successful update of the description.
        &#34;&#34;&#34;
        assert (
            self._mode == AccessMode.OWNER or self._permission == Permission.FULL_WRITE
        )

        debug(f&#34;\n\t{self.name} called on editMetaData {value}\n&#34;)
        description_file_path = self.getDescriptionPath(self._path)

        # Overwrite the existing description with the new value
        with open(description_file_path, &#34;w&#34;) as file:
            file.write(value)

        return f&#39;&#34;{self.name}&#34; Edit Success&#39;

    
    def _updateMetaForCopy(self, dest: Path):
        &#34;&#34;&#34;
        Updates the metadata for a file or directory when it is copied to a new location.

        Args:
            dest: The destination path where the file or directory has been copied.
        &#34;&#34;&#34;
        source_metadata = self._metadata_dir / self._path
        dest_metadata = self._metadata_dir / dest
        
        if self._type == FileType.DIRECTORY:
            shutil.copytree(source_metadata, dest_metadata)
        
        source_metadata_path = self._getMetaDataPath(source_metadata)
        dest_metadata_path = self._getMetaDataPath(dest_metadata)
        shutil.copy2(source_metadata_path, dest_metadata_path)

        source_desc_path = self._getDescriptionPath(source_metadata)
        dest_desc_path = self._getDescriptionPath(dest_metadata)
        shutil.copy2(source_desc_path, dest_desc_path)
        
    
    def _copy(self, dest_dir: &#34;QuetzalFile&#34;) -&gt; str:
        &#34;&#34;&#34;
        Copies the current file or directory to a new destination within the Quetzal file system, updating metadata
        accordingly.

        This method copies the file/directory represented by this instance to the specified destination directory,
        also handling metadata and description files to reflect the new location.

        Args:
            dest_dir (QueztalFile): The destination `QuetzalFile` directory where this file/directory is to be copied.

        Returns:
            A string message indicating the successful copy operation.
        &#34;&#34;&#34;
        debug(f&#34;{self.name} called on copy to &#34;, dest_dir)
        assert dest_dir._type == FileType.DIRECTORY

        # Adjust Destination relative Path
        destination_path = dest_dir._abs_path
        dest_dir: Path = destination_path.relative_to(self._root_dir.absolute())

        # Rename destination if it is duplicates
        dest = getCopyName(self._root_dir / dest_dir / self._path.name)
        
        # Copy target File
        source = self._root_dir / self._path
        if self._type == FileType.DIRECTORY:
            shutil.copytree(source, dest)
        else:
            shutil.copy2(source, dest)
        
        # Update metaData
        self._updateMetaForCopy(dest.relative_to(self._root_dir))
        
        return f&#39;&#34;{self.name}&#34; copied to &#34;{dest_dir}&#34;&#39;
            

    def _updateMetaForMove(self, dest_dir: Path):
        &#34;&#34;&#34;
        Updates the metadata for a file or directory when it is moved to a new location.

        This includes moving the metadata and description files to reflect the new file path and updating any
        directory-specific metadata if the moved entity is a directory.

        Args:
            dest_dir (Path): The destination path where the file or directory has been moved.
        &#34;&#34;&#34;
        source_metadata = self._metadata_dir / self._path
        
        if self._type == FileType.DIRECTORY:
            dest_metadata = self._metadata_dir / dest_dir
            shutil.move(source_metadata, dest_metadata)
        else:
            dest_metadata = self._metadata_dir / dest_dir / self._path.name

        source_metadata_path = self._getMetaDataPath(source_metadata)
        dest_metadata_path = self._getMetaDataPath(dest_metadata)
        shutil.move(source_metadata_path, dest_metadata_path)

        source_desc_path = self._getDescriptionPath(source_metadata)
        dest_desc_path = self._getDescriptionPath(dest_metadata)
        shutil.move(source_desc_path, dest_desc_path)
        
    
    def _move(self, dest_dir: &#34;QuetzalFile&#34;) -&gt; str:
        &#34;&#34;&#34;
        Moves the current file or directory to a new destination within the Quetzal file system, updating metadata
        accordingly.

        This method moves the file/directory represented by this instance to the specified destination directory,
        handling metadata and description files to reflect the new location. It also ensures that the move does not
        violate any system rules, such as moving into a subdirectory of itself.

        Args:
            dest_dir (QuetzalFile): The destination `QuetzalFile` directory where this file/directory is to be moved.

        Returns:
            A string message indicating the successful move operation.
        &#34;&#34;&#34;
        assert (
            self._mode == AccessMode.OWNER or self._permission == Permission.FULL_WRITE
        )
        debug(f&#34;{self.name} called on move to &#34;, dest_dir)

         # Adjust Destination relative Path
        destination_path = dest_dir._abs_path
        dest_dir: Path = destination_path.relative_to(self._root_dir.absolute())

        # Varify destination is valid
        source = self._root_dir / self._path
        dest = self._root_dir / dest_dir

        if (dest / self._path.name).exists():
            raise FileExistsError(
                f&#39;File/directory with name &#34;{self._path.name}&#34; already exist at the destination.&#39;
            )

        if dest.is_relative_to(source):
            raise Exception(f&#34;You can&#39;t move a directory into itself.&#34;)

        # Move file, metadata, and description
        if self._type == FileType.DIRECTORY:
            shutil.move(source, dest)
        else:
            dest = dest / self._path.name
            shutil.move(source, dest)
        
        # Update metaData
        self._updateMetaForMove(dest_dir)
        
        return f&#39;&#34;{self.name}&#34; moved to &#34;{dest_dir}&#34;&#39;
    

    @staticmethod
    def _getMetaDataPath(path: Path) -&gt; Path:
        &#34;&#34;&#34;
        Constructs and returns the full path to the metadata file for a given absolute file or directory path.

        Args:
            path (Path): The path to the file or directory whose metadata path is to be constructed.

        Returns:
            The full `Path` object pointing to the metadata file.
        &#34;&#34;&#34;
        return path.with_name(path.name + META_SUFFIX)

    @staticmethod
    def _getDescriptionPath(path: Path) -&gt; Path:
        &#34;&#34;&#34;
        Constructs and returns the full path to the description file for a given file or directory path.

        Args:
            path (Path): The path to the file or directory whose description path is to be constructed.

        Returns:
            The full `Path` object pointing to the description file.
        &#34;&#34;&#34;
        return path.with_name(path.name + INFO_SUFFIX)

    def getMetaDataPath(self, path: Path) -&gt; Path:
        &#34;&#34;&#34;
        Retrieves the full path to the metadata file associated with a given file or directory path, 
        based on current QuetzalFile configuration.

        Args:
            path (Path): The path to the file or directory whose metadata file path is to be retrieved.

        Returns:
            The full `Path` object pointing to the metadata file.
        &#34;&#34;&#34;
        return self._getMetaDataPath(self._metadata_dir / path)

    def getDescriptionPath(self, path: Path):
        &#34;&#34;&#34;
        Retrieves the full path to the description file associated with a given file or directory path, 
        based on current QuetzalFile configuration.

        Args:
            path (Path): The path to the file or directory whose description file path is to be retrieved.

        Returns:
            The full `Path` object pointing to the description file.
        &#34;&#34;&#34;
        return self._getDescriptionPath(self._metadata_dir / path)

    def _makeDefaultDescription(self, path: Union[str, Path]):
        &#34;&#34;&#34;
        Creates a default description file for a file or directory if one does not already exist.

        This method is typically called when a new file or directory is added to ensure that it has a basic description.

        Args:
            path: The path to the file or directory for which a default description is to be created.
        &#34;&#34;&#34;
        if self._type == FileType.DIRECTORY:
            default_content = self.PROJECT_DEFAULT_DESCRIPTION
        else:
            default_content = self.FILE_DEFAULT_DESCRIPTION

        with open(path, &#34;w&#34;) as file:
            file.write(default_content)

    def getDescription(self) -&gt; str:
        &#34;&#34;&#34;
        Retrieves the description of the current file or directory.

        If a description file does not exist, a default description is created and then retrieved.

        Returns:
            The description text of the file or directory.
        &#34;&#34;&#34;
        description_file_path = self.getDescriptionPath(self._path)

        # if not os.path.exists(description_file_path):
        if not description_file_path.exists():
            self._makeDefaultDescription(description_file_path)

        with open(description_file_path, &#34;r&#34;) as file:
            return file.read()

    def __format__(self, __format_spec: str) -&gt; str:
        return (
            &#34;\n&#34;.join(
                [
                    &#34;&lt;QueztalFile::=&#34; + str(self._path) + &#34;&gt;&#34;,
                    &#34;type::= &#34; + str(self._type),
                    &#34;createdby::= &#34; + str(self._created_by),
                    &#34;user::= &#34; + str(self._owner),
                    &#34;permission::= &#34; + str(self._permission),
                    &#34;visibility::= &#34; + str(self._visibility),
                    &#34;analysis_progress::= &#34; + str(self._analysis_progress),
                ]
            )
            + &#34;\n&#34;
        )

    def __repr__(self) -&gt; str:
        return (
            &#34;\n&#34;.join(
                [
                    &#34;&lt;QueztalFile::=&#34; + str(self._path) + &#34;&gt;&#34;,
                    &#34;type::= &#34; + str(self._type),
                    &#34;createdby::= &#34; + str(self._created_by),
                    &#34;user::= &#34; + str(self._owner),
                    &#34;permission::= &#34; + str(self._permission),
                    &#34;visibility::= &#34; + str(self._visibility),
                    &#34;analysis_progress::= &#34; + str(self._analysis_progress),
                ]
            )
            + &#34;\n&#34;
        )


## LET pdoc3 to generate documentation for private methods 
__pdoc__ = {name: True
            for name, klass in globals().items()
            if name.startswith(&#39;_&#39;) and isinstance(klass, type)}
__pdoc__.update({f&#39;{name}.{member}&#39;: True
                 for name, klass in globals().items()
                 if isinstance(klass, type)
                 for member in klass.__dict__.keys()
                 if member not in {&#39;__module__&#39;, &#39;__dict__&#39;, 
                                   &#39;__weakref__&#39;, &#39;__doc__&#39;}})</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="quetzal.dtos.dtos.appendText"><code class="name flex">
<span>def <span class="ident">appendText</span></span>(<span>path:pathlib.Path, text:str) >pathlib.Path</span>
</code></dt>
<dd>
<div class="desc"><p>Appends text to the file name, before the file extension.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>Path</code></dt>
<dd>The original file path.</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>The text to append.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Path</code></dt>
<dd>The new file path with the text appended.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def appendText(path: Path, text: str) -&gt; Path:
    &#34;&#34;&#34;Appends text to the file name, before the file extension.

    Args:
        path (Path): The original file path.
        text (str): The text to append.

    Returns:
        Path: The new file path with the text appended.
    &#34;&#34;&#34;
    return path.with_name(path.stem + text + path.suffix)</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.debug"><code class="name flex">
<span>def <span class="ident">debug</span></span>(<span>*args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">debug = lambda *args: logger.debug(&#34; &#34;.join([str(arg) for arg in args]))</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.getCopyName"><code class="name flex">
<span>def <span class="ident">getCopyName</span></span>(<span>path:pathlib.Path) >pathlib.Path</span>
</code></dt>
<dd>
<div class="desc"><p>The function iteratively appends '_copy' to the base name, before the file extension, of the provided path
until a non-existing path is generated.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>A Path object representing the original file or directory.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Path object representing the new, unique path with '_copy' appended.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCopyName(path: Path) -&gt; Path:
    &#34;&#34;&#34;The function iteratively appends &#39;_copy&#39; to the base name, before the file extension, of the provided path
    until a non-existing path is generated.

    Args:
        path: A Path object representing the original file or directory.

    Returns:
        A Path object representing the new, unique path with &#39;_copy&#39; appended.
    &#34;&#34;&#34;
    while path.exists():
        path = appendText(path, &#34;_copy&#34;)
    return path</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="quetzal.dtos.dtos.AccessMode"><code class="flex name class">
<span>class <span class="ident">AccessMode</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines access modes based on user relation to the file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AccessMode(Enum):
    &#34;&#34;&#34;Defines access modes based on user relation to the file.&#34;&#34;&#34;
    OTHERS = &#34;others&#34;
    OWNER = &#34;owner&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="quetzal.dtos.dtos.AccessMode.OTHERS"><code class="name">var <span class="ident">OTHERS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.AccessMode.OWNER"><code class="name">var <span class="ident">OWNER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.AccessMode._member_map_"><code class="name">var <span class="ident">_member_map_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.AccessMode._member_names_"><code class="name">var <span class="ident">_member_names_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.AccessMode._member_type_"><code class="name">var <span class="ident">_member_type_</span></code></dt>
<dd>
<div class="desc"><p>The base class of the class hierarchy.</p>
<p>When called, it accepts no arguments and returns a new featureless
instance that has no instance attributes and cannot be given any.</p></div>
</dd>
<dt id="quetzal.dtos.dtos.AccessMode._unhashable_values_"><code class="name">var <span class="ident">_unhashable_values_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.AccessMode._use_args_"><code class="name">var <span class="ident">_use_args_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.AccessMode._value2member_map_"><code class="name">var <span class="ident">_value2member_map_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.AccessMode._value_repr_"><code class="name">var <span class="ident">_value_repr_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="quetzal.dtos.dtos.AccessMode.__new__"><code class="name flex">
<span>def <span class="ident">__new__</span></span>(<span>cls, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Create and return a new object.
See help(type) for accurate signature.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __new__(cls, value):
    # all enum instances are actually created during class construction
    # without calling this method; this method is called by the metaclass&#39;
    # __call__ (i.e. Color(3) ), and by pickle
    if type(value) is cls:
        # For lookups like Color(Color.RED)
        return value
    # by-value search for a matching enum member
    # see if it&#39;s in the reverse mapping (for hashable values)
    try:
        return cls._value2member_map_[value]
    except KeyError:
        # Not found, no need to do long O(n) search
        pass
    except TypeError:
        # not there, now do long search -- O(n) behavior
        for member in cls._member_map_.values():
            if member._value_ == value:
                return member
    # still not found -- verify that members exist, in-case somebody got here mistakenly
    # (such as via super when trying to override __new__)
    if not cls._member_map_:
        raise TypeError(&#34;%r has no members defined&#34; % cls)
    #
    # still not found -- try _missing_ hook
    try:
        exc = None
        result = cls._missing_(value)
    except Exception as e:
        exc = e
        result = None
    try:
        if isinstance(result, cls):
            return result
        elif (
                Flag is not None and issubclass(cls, Flag)
                and cls._boundary_ is EJECT and isinstance(result, int)
            ):
            return result
        else:
            ve_exc = ValueError(&#34;%r is not a valid %s&#34; % (value, cls.__qualname__))
            if result is None and exc is None:
                raise ve_exc
            elif exc is None:
                exc = TypeError(
                        &#39;error in %s._missing_: returned %r instead of None or a valid member&#39;
                        % (cls.__name__, result)
                        )
            if not isinstance(exc, ValueError):
                exc.__context__ = ve_exc
            raise exc
    finally:
        # ensure all variables that could hold an exception are destroyed
        exc = None
        ve_exc = None</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.AccessMode._generate_next_value_"><code class="name flex">
<span>def <span class="ident">_generate_next_value_</span></span>(<span>name, start, count, last_values)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the next value when not given.</p>
<p>name: the name of the member
start: the initial start value or None
count: the number of existing members
last_values: the list of values assigned</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _generate_next_value_(name, start, count, last_values):
    &#34;&#34;&#34;
    Generate the next value when not given.

    name: the name of the member
    start: the initial start value or None
    count: the number of existing members
    last_values: the list of values assigned
    &#34;&#34;&#34;
    if not last_values:
        return start
    try:
        last = last_values[-1]
        last_values.sort()
        if last == last_values[-1]:
            # no difference between old and new methods
            return last + 1
        else:
            # trigger old method (with warning)
            raise TypeError
    except TypeError:
        import warnings
        warnings.warn(
                &#34;In 3.13 the default `auto()`/`_generate_next_value_` will require all values to be sortable and support adding +1\n&#34;
                &#34;and the value returned will be the largest value in the enum incremented by 1&#34;,
                DeprecationWarning,
                stacklevel=3,
                )
        for v in reversed(last_values):
            try:
                return v + 1
            except TypeError:
                pass
        return start</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.AccessMode._new_member_"><code class="name flex">
<span>def <span class="ident">_new_member_</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create and return a new object.
See help(type) for accurate signature.</p></div>
</dd>
</dl>
</dd>
<dt id="quetzal.dtos.dtos.Action"><code class="flex name class">
<span>class <span class="ident">Action</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines possible actions that can be performed on files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Action(Enum):
    &#34;&#34;&#34;Defines possible actions that can be performed on files.&#34;&#34;&#34;
    NEW_DIR = &#34;new_dir&#34;
    UPLOAD_FILE = &#34;upload_file&#34;
    RENAME = &#34;rename&#34;
    SHARE = &#34;share&#34;
    DELETE = &#34;delete&#34;
    DOWNLOAD = &#34;download&#34;
    ANALYZE = &#34;analyze&#34;
    EDIT = &#34;edit&#34;
    COPY = &#34;copy&#34;
    MOVE = &#34;move&#34;
    # WAIT = &#34;wait&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="quetzal.dtos.dtos.Action.ANALYZE"><code class="name">var <span class="ident">ANALYZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.Action.COPY"><code class="name">var <span class="ident">COPY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.Action.DELETE"><code class="name">var <span class="ident">DELETE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.Action.DOWNLOAD"><code class="name">var <span class="ident">DOWNLOAD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.Action.EDIT"><code class="name">var <span class="ident">EDIT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.Action.MOVE"><code class="name">var <span class="ident">MOVE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.Action.NEW_DIR"><code class="name">var <span class="ident">NEW_DIR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.Action.RENAME"><code class="name">var <span class="ident">RENAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.Action.SHARE"><code class="name">var <span class="ident">SHARE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.Action.UPLOAD_FILE"><code class="name">var <span class="ident">UPLOAD_FILE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.Action._member_map_"><code class="name">var <span class="ident">_member_map_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.Action._member_names_"><code class="name">var <span class="ident">_member_names_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.Action._member_type_"><code class="name">var <span class="ident">_member_type_</span></code></dt>
<dd>
<div class="desc"><p>The base class of the class hierarchy.</p>
<p>When called, it accepts no arguments and returns a new featureless
instance that has no instance attributes and cannot be given any.</p></div>
</dd>
<dt id="quetzal.dtos.dtos.Action._unhashable_values_"><code class="name">var <span class="ident">_unhashable_values_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.Action._use_args_"><code class="name">var <span class="ident">_use_args_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.Action._value2member_map_"><code class="name">var <span class="ident">_value2member_map_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.Action._value_repr_"><code class="name">var <span class="ident">_value_repr_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="quetzal.dtos.dtos.Action.__new__"><code class="name flex">
<span>def <span class="ident">__new__</span></span>(<span>cls, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Create and return a new object.
See help(type) for accurate signature.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __new__(cls, value):
    # all enum instances are actually created during class construction
    # without calling this method; this method is called by the metaclass&#39;
    # __call__ (i.e. Color(3) ), and by pickle
    if type(value) is cls:
        # For lookups like Color(Color.RED)
        return value
    # by-value search for a matching enum member
    # see if it&#39;s in the reverse mapping (for hashable values)
    try:
        return cls._value2member_map_[value]
    except KeyError:
        # Not found, no need to do long O(n) search
        pass
    except TypeError:
        # not there, now do long search -- O(n) behavior
        for member in cls._member_map_.values():
            if member._value_ == value:
                return member
    # still not found -- verify that members exist, in-case somebody got here mistakenly
    # (such as via super when trying to override __new__)
    if not cls._member_map_:
        raise TypeError(&#34;%r has no members defined&#34; % cls)
    #
    # still not found -- try _missing_ hook
    try:
        exc = None
        result = cls._missing_(value)
    except Exception as e:
        exc = e
        result = None
    try:
        if isinstance(result, cls):
            return result
        elif (
                Flag is not None and issubclass(cls, Flag)
                and cls._boundary_ is EJECT and isinstance(result, int)
            ):
            return result
        else:
            ve_exc = ValueError(&#34;%r is not a valid %s&#34; % (value, cls.__qualname__))
            if result is None and exc is None:
                raise ve_exc
            elif exc is None:
                exc = TypeError(
                        &#39;error in %s._missing_: returned %r instead of None or a valid member&#39;
                        % (cls.__name__, result)
                        )
            if not isinstance(exc, ValueError):
                exc.__context__ = ve_exc
            raise exc
    finally:
        # ensure all variables that could hold an exception are destroyed
        exc = None
        ve_exc = None</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.Action._generate_next_value_"><code class="name flex">
<span>def <span class="ident">_generate_next_value_</span></span>(<span>name, start, count, last_values)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the next value when not given.</p>
<p>name: the name of the member
start: the initial start value or None
count: the number of existing members
last_values: the list of values assigned</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _generate_next_value_(name, start, count, last_values):
    &#34;&#34;&#34;
    Generate the next value when not given.

    name: the name of the member
    start: the initial start value or None
    count: the number of existing members
    last_values: the list of values assigned
    &#34;&#34;&#34;
    if not last_values:
        return start
    try:
        last = last_values[-1]
        last_values.sort()
        if last == last_values[-1]:
            # no difference between old and new methods
            return last + 1
        else:
            # trigger old method (with warning)
            raise TypeError
    except TypeError:
        import warnings
        warnings.warn(
                &#34;In 3.13 the default `auto()`/`_generate_next_value_` will require all values to be sortable and support adding +1\n&#34;
                &#34;and the value returned will be the largest value in the enum incremented by 1&#34;,
                DeprecationWarning,
                stacklevel=3,
                )
        for v in reversed(last_values):
            try:
                return v + 1
            except TypeError:
                pass
        return start</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.Action._new_member_"><code class="name flex">
<span>def <span class="ident">_new_member_</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create and return a new object.
See help(type) for accurate signature.</p></div>
</dd>
</dl>
</dd>
<dt id="quetzal.dtos.dtos.AnalysisProgress"><code class="flex name class">
<span>class <span class="ident">AnalysisProgress</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the progress of analysis on a file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnalysisProgress(Enum):
    &#34;&#34;&#34;Represents the progress of analysis on a file.&#34;&#34;&#34;
    FULL = &#34;full&#34;
    HALF = &#34;half&#34;
    NONE = &#34;none&#34;

    def __eq__(self, other):
        if isinstance(other, AnalysisProgress):
            return self.value == other.value
        return NotImplemented

    def __lt__(self, other):
        if isinstance(other, AnalysisProgress):
            return self.value &gt; other.value
        return NotImplemented

    def __le__(self, other):
        if isinstance(other, AnalysisProgress):
            return self.value &gt;= other.value
        return NotImplemented

    def __gt__(self, other):
        if isinstance(other, AnalysisProgress):
            return self.value &lt; other.value
        return NotImplemented

    def __ge__(self, other):
        if isinstance(other, AnalysisProgress):
            return self.value &lt;= other.value
        return NotImplemented

    def __hash__(self):
        return hash(self.value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="quetzal.dtos.dtos.AnalysisProgress.FULL"><code class="name">var <span class="ident">FULL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.AnalysisProgress.HALF"><code class="name">var <span class="ident">HALF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.AnalysisProgress.NONE"><code class="name">var <span class="ident">NONE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.AnalysisProgress._member_map_"><code class="name">var <span class="ident">_member_map_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.AnalysisProgress._member_names_"><code class="name">var <span class="ident">_member_names_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.AnalysisProgress._member_type_"><code class="name">var <span class="ident">_member_type_</span></code></dt>
<dd>
<div class="desc"><p>The base class of the class hierarchy.</p>
<p>When called, it accepts no arguments and returns a new featureless
instance that has no instance attributes and cannot be given any.</p></div>
</dd>
<dt id="quetzal.dtos.dtos.AnalysisProgress._unhashable_values_"><code class="name">var <span class="ident">_unhashable_values_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.AnalysisProgress._use_args_"><code class="name">var <span class="ident">_use_args_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.AnalysisProgress._value2member_map_"><code class="name">var <span class="ident">_value2member_map_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.AnalysisProgress._value_repr_"><code class="name">var <span class="ident">_value_repr_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="quetzal.dtos.dtos.AnalysisProgress.__eq__"><code class="name flex">
<span>def <span class="ident">__eq__</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Return self==value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __eq__(self, other):
    if isinstance(other, AnalysisProgress):
        return self.value == other.value
    return NotImplemented</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.AnalysisProgress.__ge__"><code class="name flex">
<span>def <span class="ident">__ge__</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Return self&gt;=value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __ge__(self, other):
    if isinstance(other, AnalysisProgress):
        return self.value &lt;= other.value
    return NotImplemented</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.AnalysisProgress.__gt__"><code class="name flex">
<span>def <span class="ident">__gt__</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Return self&gt;value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __gt__(self, other):
    if isinstance(other, AnalysisProgress):
        return self.value &lt; other.value
    return NotImplemented</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.AnalysisProgress.__hash__"><code class="name flex">
<span>def <span class="ident">__hash__</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return hash(self).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __hash__(self):
    return hash(self.value)</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.AnalysisProgress.__le__"><code class="name flex">
<span>def <span class="ident">__le__</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Return self&lt;=value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __le__(self, other):
    if isinstance(other, AnalysisProgress):
        return self.value &gt;= other.value
    return NotImplemented</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.AnalysisProgress.__lt__"><code class="name flex">
<span>def <span class="ident">__lt__</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Return self&lt;value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __lt__(self, other):
    if isinstance(other, AnalysisProgress):
        return self.value &gt; other.value
    return NotImplemented</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.AnalysisProgress.__new__"><code class="name flex">
<span>def <span class="ident">__new__</span></span>(<span>cls, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Create and return a new object.
See help(type) for accurate signature.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __new__(cls, value):
    # all enum instances are actually created during class construction
    # without calling this method; this method is called by the metaclass&#39;
    # __call__ (i.e. Color(3) ), and by pickle
    if type(value) is cls:
        # For lookups like Color(Color.RED)
        return value
    # by-value search for a matching enum member
    # see if it&#39;s in the reverse mapping (for hashable values)
    try:
        return cls._value2member_map_[value]
    except KeyError:
        # Not found, no need to do long O(n) search
        pass
    except TypeError:
        # not there, now do long search -- O(n) behavior
        for member in cls._member_map_.values():
            if member._value_ == value:
                return member
    # still not found -- verify that members exist, in-case somebody got here mistakenly
    # (such as via super when trying to override __new__)
    if not cls._member_map_:
        raise TypeError(&#34;%r has no members defined&#34; % cls)
    #
    # still not found -- try _missing_ hook
    try:
        exc = None
        result = cls._missing_(value)
    except Exception as e:
        exc = e
        result = None
    try:
        if isinstance(result, cls):
            return result
        elif (
                Flag is not None and issubclass(cls, Flag)
                and cls._boundary_ is EJECT and isinstance(result, int)
            ):
            return result
        else:
            ve_exc = ValueError(&#34;%r is not a valid %s&#34; % (value, cls.__qualname__))
            if result is None and exc is None:
                raise ve_exc
            elif exc is None:
                exc = TypeError(
                        &#39;error in %s._missing_: returned %r instead of None or a valid member&#39;
                        % (cls.__name__, result)
                        )
            if not isinstance(exc, ValueError):
                exc.__context__ = ve_exc
            raise exc
    finally:
        # ensure all variables that could hold an exception are destroyed
        exc = None
        ve_exc = None</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.AnalysisProgress._generate_next_value_"><code class="name flex">
<span>def <span class="ident">_generate_next_value_</span></span>(<span>name, start, count, last_values)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the next value when not given.</p>
<p>name: the name of the member
start: the initial start value or None
count: the number of existing members
last_values: the list of values assigned</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _generate_next_value_(name, start, count, last_values):
    &#34;&#34;&#34;
    Generate the next value when not given.

    name: the name of the member
    start: the initial start value or None
    count: the number of existing members
    last_values: the list of values assigned
    &#34;&#34;&#34;
    if not last_values:
        return start
    try:
        last = last_values[-1]
        last_values.sort()
        if last == last_values[-1]:
            # no difference between old and new methods
            return last + 1
        else:
            # trigger old method (with warning)
            raise TypeError
    except TypeError:
        import warnings
        warnings.warn(
                &#34;In 3.13 the default `auto()`/`_generate_next_value_` will require all values to be sortable and support adding +1\n&#34;
                &#34;and the value returned will be the largest value in the enum incremented by 1&#34;,
                DeprecationWarning,
                stacklevel=3,
                )
        for v in reversed(last_values):
            try:
                return v + 1
            except TypeError:
                pass
        return start</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.AnalysisProgress._new_member_"><code class="name flex">
<span>def <span class="ident">_new_member_</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create and return a new object.
See help(type) for accurate signature.</p></div>
</dd>
</dl>
</dd>
<dt id="quetzal.dtos.dtos.FileType"><code class="flex name class">
<span>class <span class="ident">FileType</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the type of a file system object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FileType(Enum):
    &#34;&#34;&#34;Defines the type of a file system object.&#34;&#34;&#34;
    FILE = &#34;file&#34;
    DIRECTORY = &#34;directory&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="quetzal.dtos.dtos.FileType.DIRECTORY"><code class="name">var <span class="ident">DIRECTORY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.FileType.FILE"><code class="name">var <span class="ident">FILE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.FileType._member_map_"><code class="name">var <span class="ident">_member_map_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.FileType._member_names_"><code class="name">var <span class="ident">_member_names_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.FileType._member_type_"><code class="name">var <span class="ident">_member_type_</span></code></dt>
<dd>
<div class="desc"><p>The base class of the class hierarchy.</p>
<p>When called, it accepts no arguments and returns a new featureless
instance that has no instance attributes and cannot be given any.</p></div>
</dd>
<dt id="quetzal.dtos.dtos.FileType._unhashable_values_"><code class="name">var <span class="ident">_unhashable_values_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.FileType._use_args_"><code class="name">var <span class="ident">_use_args_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.FileType._value2member_map_"><code class="name">var <span class="ident">_value2member_map_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.FileType._value_repr_"><code class="name">var <span class="ident">_value_repr_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="quetzal.dtos.dtos.FileType.__new__"><code class="name flex">
<span>def <span class="ident">__new__</span></span>(<span>cls, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Create and return a new object.
See help(type) for accurate signature.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __new__(cls, value):
    # all enum instances are actually created during class construction
    # without calling this method; this method is called by the metaclass&#39;
    # __call__ (i.e. Color(3) ), and by pickle
    if type(value) is cls:
        # For lookups like Color(Color.RED)
        return value
    # by-value search for a matching enum member
    # see if it&#39;s in the reverse mapping (for hashable values)
    try:
        return cls._value2member_map_[value]
    except KeyError:
        # Not found, no need to do long O(n) search
        pass
    except TypeError:
        # not there, now do long search -- O(n) behavior
        for member in cls._member_map_.values():
            if member._value_ == value:
                return member
    # still not found -- verify that members exist, in-case somebody got here mistakenly
    # (such as via super when trying to override __new__)
    if not cls._member_map_:
        raise TypeError(&#34;%r has no members defined&#34; % cls)
    #
    # still not found -- try _missing_ hook
    try:
        exc = None
        result = cls._missing_(value)
    except Exception as e:
        exc = e
        result = None
    try:
        if isinstance(result, cls):
            return result
        elif (
                Flag is not None and issubclass(cls, Flag)
                and cls._boundary_ is EJECT and isinstance(result, int)
            ):
            return result
        else:
            ve_exc = ValueError(&#34;%r is not a valid %s&#34; % (value, cls.__qualname__))
            if result is None and exc is None:
                raise ve_exc
            elif exc is None:
                exc = TypeError(
                        &#39;error in %s._missing_: returned %r instead of None or a valid member&#39;
                        % (cls.__name__, result)
                        )
            if not isinstance(exc, ValueError):
                exc.__context__ = ve_exc
            raise exc
    finally:
        # ensure all variables that could hold an exception are destroyed
        exc = None
        ve_exc = None</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.FileType._generate_next_value_"><code class="name flex">
<span>def <span class="ident">_generate_next_value_</span></span>(<span>name, start, count, last_values)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the next value when not given.</p>
<p>name: the name of the member
start: the initial start value or None
count: the number of existing members
last_values: the list of values assigned</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _generate_next_value_(name, start, count, last_values):
    &#34;&#34;&#34;
    Generate the next value when not given.

    name: the name of the member
    start: the initial start value or None
    count: the number of existing members
    last_values: the list of values assigned
    &#34;&#34;&#34;
    if not last_values:
        return start
    try:
        last = last_values[-1]
        last_values.sort()
        if last == last_values[-1]:
            # no difference between old and new methods
            return last + 1
        else:
            # trigger old method (with warning)
            raise TypeError
    except TypeError:
        import warnings
        warnings.warn(
                &#34;In 3.13 the default `auto()`/`_generate_next_value_` will require all values to be sortable and support adding +1\n&#34;
                &#34;and the value returned will be the largest value in the enum incremented by 1&#34;,
                DeprecationWarning,
                stacklevel=3,
                )
        for v in reversed(last_values):
            try:
                return v + 1
            except TypeError:
                pass
        return start</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.FileType._new_member_"><code class="name flex">
<span>def <span class="ident">_new_member_</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create and return a new object.
See help(type) for accurate signature.</p></div>
</dd>
</dl>
</dd>
<dt id="quetzal.dtos.dtos.Permission"><code class="flex name class">
<span>class <span class="ident">Permission</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines access permissions for files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Permission(Enum):
    &#34;&#34;&#34;Defines access permissions for files.&#34;&#34;&#34;
    READ_ONLY = &#34;read_only&#34;
    POST_ONLY = &#34;post_only&#34;
    FULL_WRITE = &#34;full_write&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="quetzal.dtos.dtos.Permission.FULL_WRITE"><code class="name">var <span class="ident">FULL_WRITE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.Permission.POST_ONLY"><code class="name">var <span class="ident">POST_ONLY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.Permission.READ_ONLY"><code class="name">var <span class="ident">READ_ONLY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.Permission._member_map_"><code class="name">var <span class="ident">_member_map_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.Permission._member_names_"><code class="name">var <span class="ident">_member_names_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.Permission._member_type_"><code class="name">var <span class="ident">_member_type_</span></code></dt>
<dd>
<div class="desc"><p>The base class of the class hierarchy.</p>
<p>When called, it accepts no arguments and returns a new featureless
instance that has no instance attributes and cannot be given any.</p></div>
</dd>
<dt id="quetzal.dtos.dtos.Permission._unhashable_values_"><code class="name">var <span class="ident">_unhashable_values_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.Permission._use_args_"><code class="name">var <span class="ident">_use_args_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.Permission._value2member_map_"><code class="name">var <span class="ident">_value2member_map_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.Permission._value_repr_"><code class="name">var <span class="ident">_value_repr_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="quetzal.dtos.dtos.Permission.__new__"><code class="name flex">
<span>def <span class="ident">__new__</span></span>(<span>cls, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Create and return a new object.
See help(type) for accurate signature.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __new__(cls, value):
    # all enum instances are actually created during class construction
    # without calling this method; this method is called by the metaclass&#39;
    # __call__ (i.e. Color(3) ), and by pickle
    if type(value) is cls:
        # For lookups like Color(Color.RED)
        return value
    # by-value search for a matching enum member
    # see if it&#39;s in the reverse mapping (for hashable values)
    try:
        return cls._value2member_map_[value]
    except KeyError:
        # Not found, no need to do long O(n) search
        pass
    except TypeError:
        # not there, now do long search -- O(n) behavior
        for member in cls._member_map_.values():
            if member._value_ == value:
                return member
    # still not found -- verify that members exist, in-case somebody got here mistakenly
    # (such as via super when trying to override __new__)
    if not cls._member_map_:
        raise TypeError(&#34;%r has no members defined&#34; % cls)
    #
    # still not found -- try _missing_ hook
    try:
        exc = None
        result = cls._missing_(value)
    except Exception as e:
        exc = e
        result = None
    try:
        if isinstance(result, cls):
            return result
        elif (
                Flag is not None and issubclass(cls, Flag)
                and cls._boundary_ is EJECT and isinstance(result, int)
            ):
            return result
        else:
            ve_exc = ValueError(&#34;%r is not a valid %s&#34; % (value, cls.__qualname__))
            if result is None and exc is None:
                raise ve_exc
            elif exc is None:
                exc = TypeError(
                        &#39;error in %s._missing_: returned %r instead of None or a valid member&#39;
                        % (cls.__name__, result)
                        )
            if not isinstance(exc, ValueError):
                exc.__context__ = ve_exc
            raise exc
    finally:
        # ensure all variables that could hold an exception are destroyed
        exc = None
        ve_exc = None</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.Permission._generate_next_value_"><code class="name flex">
<span>def <span class="ident">_generate_next_value_</span></span>(<span>name, start, count, last_values)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the next value when not given.</p>
<p>name: the name of the member
start: the initial start value or None
count: the number of existing members
last_values: the list of values assigned</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _generate_next_value_(name, start, count, last_values):
    &#34;&#34;&#34;
    Generate the next value when not given.

    name: the name of the member
    start: the initial start value or None
    count: the number of existing members
    last_values: the list of values assigned
    &#34;&#34;&#34;
    if not last_values:
        return start
    try:
        last = last_values[-1]
        last_values.sort()
        if last == last_values[-1]:
            # no difference between old and new methods
            return last + 1
        else:
            # trigger old method (with warning)
            raise TypeError
    except TypeError:
        import warnings
        warnings.warn(
                &#34;In 3.13 the default `auto()`/`_generate_next_value_` will require all values to be sortable and support adding +1\n&#34;
                &#34;and the value returned will be the largest value in the enum incremented by 1&#34;,
                DeprecationWarning,
                stacklevel=3,
                )
        for v in reversed(last_values):
            try:
                return v + 1
            except TypeError:
                pass
        return start</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.Permission._new_member_"><code class="name flex">
<span>def <span class="ident">_new_member_</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create and return a new object.
See help(type) for accurate signature.</p></div>
</dd>
</dl>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile"><code class="flex name class">
<span>class <span class="ident">QuetzalFile</span></span>
</code></dt>
<dd>
<div class="desc"><p>Represents a file or directory within the Quetzal file system, facilitating operations such as creation,
renaming, sharing, and metadata management. This class serves as a base for specialized file types within Quetzal,
providing a structured approach to handle common file-related tasks.</p>
<p>Subclasses of <code><a title="quetzal.dtos.dtos.QuetzalFile" href="#quetzal.dtos.dtos.QuetzalFile">QuetzalFile</a></code> may implement custom behaviors for specific operations (e.g., copying, analyzing,
sharing) by overriding the internal methods designed for these purposes. For example, see the <code>Video</code> class
for implementations that tailor these operations to the needs of video file management within Quetzal.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>Path</code></dt>
<dd>The path of the file or directory, relative to the root directory.</dd>
<dt><strong><code>root_dir</code></strong> :&ensp;<code>Path</code></dt>
<dd>The root directory path of the Quetzal file system.</dd>
<dt><strong><code>metadata_dir</code></strong> :&ensp;<code>Path</code></dt>
<dd>The directory path where metadata files are stored.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a title="quetzal.dtos.dtos.User" href="#quetzal.dtos.dtos.User">User</a></code></dt>
<dd>The user who is interacting with the file.</dd>
<dt><strong><code>home</code></strong> :&ensp;<code>Path</code></dt>
<dd>The base home directory path (relative to rood directory). Defaults to "./".</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>Optional[Dict[str, MetaData]]</code></dt>
<dd>The metadata associated with the file.</dd>
<dt><strong><code>parent</code></strong> :&ensp;<code>Optional[<a title="quetzal.dtos.dtos.QuetzalFile" href="#quetzal.dtos.dtos.QuetzalFile">QuetzalFile</a>]</code></dt>
<dd>The parent directory of the current file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QuetzalFile:
    &#34;&#34;&#34;
    Represents a file or directory within the Quetzal file system, facilitating operations such as creation,
    renaming, sharing, and metadata management. This class serves as a base for specialized file types within Quetzal,
    providing a structured approach to handle common file-related tasks.

    Subclasses of `QuetzalFile` may implement custom behaviors for specific operations (e.g., copying, analyzing,
    sharing) by overriding the internal methods designed for these purposes. For example, see the `Video` class
    for implementations that tailor these operations to the needs of video file management within Quetzal.
    &#34;&#34;&#34;
    
    FILE_DEFAULT_DESCRIPTION = &#34;Uploader::= default\nRecorded Date (MM/DD/YYYY)::= default\nTime-of-day::= default\nWeather Condition::= default\nDescription::= default&#34;
    PROJECT_DEFAULT_DESCRIPTION = &#34;Route Location::= default\nLast Update (MM/DD/YYYY)::= default\nLast Edit by::= default\nDescription::= default&#34;
    FILE_DEFAULT_META = &#34;FileType::= file\nVisibility::= private\nPermission::= full_write\nAnalysisProgress::= none\nSpecificType::= Video\n&#34;
    PROJECT_DEFAULT_META = (
        &#34;FileType::= directory\nVisibility::= private\nPermission::= full_write\n&#34;
    )
    USER_ROOT_META = (
        &#34;FileType::= directory\nVisibility::= shared\nPermission::= read_only\n&#34;
    )
    USER_ROOT_DESCRIPTION = &#34;Description::=root directory for &#34;
    ROOT_META = &#34;FileType::= directory\nVisibility::= shared\nPermission::= read_only\nCreatedBy::= admin\nOwner::= admin&#34;
    ROOT_DESCRIPTOIN = &#34;Description::=database root&#34;
    

    def __init__(
        self,
        path: Union[str, Path],  # path to the dir/file from root_dir
        root_dir: Union[str, Path],
        metadata_dir: Union[str, Path],
        user: Union[str, User] = User.GuestId,
        home: Union[str, Path] = &#34;./&#34;,
        metadata: Optional[dict[str, MetaData]] = None,
        parent: &#39;QuetzalFile&#39; = None,
    ):
        &#34;&#34;&#34;        
        Args:
            path (Path): The path of the file or directory, relative to the root directory.
            root_dir (Path): The root directory path of the Quetzal file system.
            metadata_dir (Path): The directory path where metadata files are stored.
            user (User): The user who is interacting with the file.
            home (Path): The base home directory path (relative to rood directory). Defaults to &#34;./&#34;.
            metadata (Optional[Dict[str, MetaData]]): The metadata associated with the file.
            parent (Optional[QuetzalFile]): The parent directory of the current file.
        &#34;&#34;&#34;
        self._path = Path(path)
        self._root_dir = Path(root_dir)
        self._metadata_dir = Path(metadata_dir)
        self._user = User(user)
        self._home = Path(home)
        self._parent = parent

        assert self._user != &#34;example&#34;

        if not (self.full_path).exists():
            if self._path == Path(self._user.id):
                os.makedirs(self.full_path, exist_ok=True)
                info_path = self.getDescriptionPath(self._path)
                info_path.write_text(self.USER_ROOT_DESCRIPTION)
                mata_path = self.getMetaDataPath(self._path)
                mata_path.write_text(self.USER_ROOT_META + &#34;CreatedBy::= admin\n&#34; )
            else:    
                raise FileNotFoundError(
                    f&#39;File &#34;{self._root_dir / self._path}&#34; Do not Exist&#39;
                )

        if not self.getMetaDataPath(self._path).exists():
            raise FileNotFoundError(
                f&#39;Meta File &#34;{self.getMetaDataPath(self._path)}&#34; Do not Exist&#39;
            )

        if not self._path.is_relative_to(self._home):
            raise ValueError(f&#39;&#34;{path}&#34; is not relative to &#34;{home}&#34;&#39;)

        ## load_metadata
        self._parseMetadata(metadata)

        match self._path.parts:
            case [user_id, *_]:
                self._owner = User(user_id)
            case _:
                self._owner = User(ADMIN_ID)

        self._mode = (
            AccessMode.OWNER if self._owner == self._user else AccessMode.OTHERS
        )
        
        self._iterdir = None

    def __hash__(self):
        return hash(str(self.path))

    def __eq__(self, other):
        match other:
            case QuetzalFile():
                return self._path == other._path
            case str():
                return self._path == other
            case _:
                return NotImplemented

    @property
    def _abs_path(self) -&gt; Path:
        &#34;&#34;&#34;Full absolute path of the file&#34;&#34;&#34;
        return (self._root_dir / self._path).absolute()

    @property
    def path(self) -&gt; Path:
        &#34;&#34;&#34;Relative path to the file or directory from the &#34;home&#34; directory.&#34;&#34;&#34;
        return self._path.relative_to(self._home)

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;The name of the file or directory.&#34;&#34;&#34;
        return self._path.name

    @property
    def type(self) -&gt; FileType:
        &#34;&#34;&#34;The type of the file, either FILE or DIRECTORY.&#34;&#34;&#34;
        return self._type

    @property
    def full_path(self) -&gt; Path:
        &#34;&#34;&#34;The full filesystem path to the file or directory.&#34;&#34;&#34;
        return self._root_dir / self._path

    @property
    def analysis_progress(self) -&gt; AnalysisProgress:
        &#34;&#34;&#34;The current progress of any ongoing analysis.&#34;&#34;&#34;
        return self._analysis_progress

    @property
    def visibility(self) -&gt; Visibility:
        &#34;&#34;&#34;The visibility setting of the file, either SHARED or PRIVATE.&#34;&#34;&#34;
        return self._visibility

    @property
    def permission(self) -&gt; Permission:
        &#34;&#34;&#34;The access permissions of the file.&#34;&#34;&#34;
        return self._permission

    @property
    def createdBy(self) -&gt; User:
        &#34;&#34;&#34;The user who created the file.&#34;&#34;&#34;
        return self._created_by.id

    @property
    def user(self) -&gt; User:
        &#34;&#34;&#34;The current user interacting with the file.&#34;&#34;&#34;
        return self._user.id

    @property
    def home(self) -&gt; Path:
        &#34;&#34;&#34;The base home directory path.&#34;&#34;&#34;
        return self._home

    @property
    def mode(self) -&gt; AccessMode:
        &#34;&#34;&#34;The access mode, indicating if the current user is the OWNER or OTHERS.&#34;&#34;&#34;
        return self._mode

    @staticmethod
    def fromFile(file: &#34;QuetzalFile&#34;, path: Union[str, Path], home: Optional[Union[str, Path]]=None) -&gt; &#34;QuetzalFile&#34;:
        &#34;&#34;&#34;
        Creates a new instance of QuetzalFile based on an existing instance.

        Args:
            file: The QuetzalFile instance to base the new instance on.
            path: The path for the new QuetzalFile instance. Actual path relative to the root_dir will be &#34;./home/path&#34;.
            home: The home directory for the new instance. If None, the home of the &#39;file&#39; is used.

        Returns:
            A new QuetzalFile instance based on the provided file and path.
        &#34;&#34;&#34;
        
        if home is None:    
            home = file._home
        else:
            home = Path(home)
        return QuetzalFile(
            path=home / path,
            root_dir=file._root_dir,
            metadata_dir=file._metadata_dir,
            user=file._user,
            home=home
        )

    def loadMetaData(self, file: Union[str, Path]) -&gt; dict[str, MetaData]:
        &#34;&#34;&#34;
        Loads and returns the metadata for the specified file.
        &#34;&#34;&#34;
        metadata_path = self.getMetaDataPath(file)
        return self._loadMetaData(metadata_path)
    
    def iterdir(
        self,
        sharedOnly=False,
        directoryOnly=False,
    ) -&gt; list[&#34;QuetzalFile&#34;]:
        &#34;&#34;&#34;
        Lists the contents of the directory represented by this QuetzalFile.

        Args:
            sharedOnly: If True, only shared files/directories are listed.
            directoryOnly: If True, only directories are listed.

        Returns:
            A list of QuetzalFile objects representing the contents of the directory.
        &#34;&#34;&#34;
        
        assert self._type == FileType.DIRECTORY
        
        if self._iterdir:
            return self._iterdir

        directories = []
        files = []
        directory_path = self._root_dir / self._path

        sorted_items = sorted(directory_path.iterdir(), key=lambda x: x.stem.lower())
        for item in sorted_items:
            # Load MetaData of the file
            try:
                metadata = self.loadMetaData(item.relative_to(self._root_dir))
            except:
                continue

            # Filter Only Directory
            isdir = metadata[&#34;FileType&#34;] == FileType.DIRECTORY
            if directoryOnly and not isdir:
                continue

            # Filter only shared
            if sharedOnly and metadata[&#34;Visibility&#34;] != Visibility.SHARED:
                continue
            
            file = QuetzalFile._instantiateFile(
                path=item.relative_to(self._root_dir),
                root_dir=self._root_dir,
                metadata_dir=self._metadata_dir,
                user=self._user,
                home=self._home,
                metadata=metadata,
                parent=self,
            )

            # Sort to have directory first
            if isdir:
                directories.append(file)
            else:
                files.append(file)

        self._iterdir = directories + files
        return self._iterdir

    def perform(self, action: Action, input: dict):
        &#34;&#34;&#34;
        Performs the specified &#34;Action&#34; on this QuetzalFile object.

        Args:
            action: The action to perform, as defined by the Action enum.
            input: A dictionary containing the input parameters required for the action.

        Returns:
            A string message indicating the outcome of the action, or None if no action was performed.
        &#34;&#34;&#34;
        
        self._iterdir = None
        if self._parent:
            self._parent._iterdir = None
        match action:
            case Action.NEW_DIR:
                return self._newDirectory(**input)
            case Action.UPLOAD_FILE:
                return self._upload(**input)
            case Action.RENAME:
                return self._rename(**input)
            case Action.SHARE:
                return self._share(**input)
            case Action.DELETE:
                return self._delete(**input)
            case Action.ANALYZE:
                return self._analyze(**input)
            case Action.EDIT:
                return self._editDescription(**input)
            case Action.COPY:
                return self._copy(**input)
            case Action.MOVE:
                return self._move(**input)
            case _:
                raise NotImplemented(&#34;No Action Implemneted&#34;)
    
    @staticmethod
    def _instantiateFile(
        path: Path,
        root_dir: Path,
        metadata_dir: Path,
        user: User,
        home: Path,
        metadata: dict[str, MetaData],
        parent: &#39;QuetzalFile&#39;,
    ) -&gt; &#34;QuetzalFile&#34;:
        &#34;&#34;&#34;
        Instantiate a file into &#34;Specific Type&#34;, one of subclass of QuetzalFile.
        
        Args:
            path (Path): The path of the file or directory, relative to the root directory.
            root_dir (Path): The root directory path of the Quetzal file system.
            metadata_dir (Path): The directory path where metadata files are stored.
            user (User): The user who is interacting with the file.
            home (Path): The base home directory path (relative to rood directory). Defaults to &#34;./&#34;.
            metadata (Optional[Dict[str, MetaData]]): The metadata associated with the file.
            parent (Optional[QuetzalFile]): The parent directory of the current file.
        
        Returns:
            Instance of &#34;Specific Type&#34; (subclass of QuetzalFile)
        &#34;&#34;&#34;
        
        specific_file_class = None
        specific_type = metadata.get(&#34;SpecificType&#34;, None)
        
        if specific_type:
            module = importlib.import_module(f&#34;quetzal.dtos.{specific_type.lower()}&#34;)
            specific_file_class = getattr(module, specific_type)

        if specific_file_class and issubclass(specific_file_class, QuetzalFile):
            return specific_file_class(
                path=path,
                root_dir=root_dir,
                metadata_dir=metadata_dir,
                user=user,
                home=home,
                metadata=metadata,
                parent=parent,
            )
        else:
            return QuetzalFile(
                path=path,
                root_dir=root_dir,
                metadata_dir=metadata_dir,
                user=user,
                home=home,
                metadata=metadata,
                parent=parent
            )
            
    @staticmethod
    def _loadMetaData(metadata_path: Path) -&gt; dict[str, MetaData]:
        &#34;&#34;&#34;
        Load Queztalfile metadata from the given path
        
        Args:
            metadata_dir (Path): The directory path where metadata files are stored.
        
        Returns:
            dict[str, MetaData]
        &#34;&#34;&#34;
        if not os.path.exists(metadata_path):
            raise FileNotFoundError

        with open(metadata_path, &#34;r&#34;) as file:
            data = file.read().splitlines()
        metadata = {
            line.split(&#34;::=&#34;)[0].strip(): line.split(&#34;::=&#34;)[1].strip()
            for line in data
            if line.strip()
        }

        metadata[&#34;CreatedBy&#34;] = CreatedBy(User(metadata.get(&#34;CreatedBy&#34;, None)))
        metadata[&#34;FileType&#34;] = FileType(metadata.get(&#34;FileType&#34;, &#34;file&#34;))
        metadata[&#34;Visibility&#34;] = Visibility(metadata.get(&#34;Visibility&#34;, &#34;private&#34;))
        metadata[&#34;AnalysisProgress&#34;] = AnalysisProgress(
            metadata.get(&#34;AnalysisProgress&#34;, &#34;none&#34;)
        )
        metadata[&#34;Permission&#34;] = Permission(metadata.get(&#34;Permission&#34;, &#34;full_write&#34;))
        metadata[&#34;SpecificType&#34;] = SpecificType(metadata.get(&#34;SpecificType&#34;, None))

        return metadata

    def _parseMetadata(self, metadata: Optional[dict[str, MetaData]]):
        &#34;&#34;&#34;
        Assign Queztalfile metadata into attribute variables
        
        Args:
            metadata (Optional[dict[str, MetaData]]): metadata
        &#34;&#34;&#34;
        if metadata is None:
            metadata = self.loadMetaData(self._path)

        self._created_by = metadata[&#34;CreatedBy&#34;]
        self._type = metadata[&#34;FileType&#34;]
        self._visibility = metadata[&#34;Visibility&#34;]
        self._analysis_progress = metadata[&#34;AnalysisProgress&#34;]
        self._permission = metadata[&#34;Permission&#34;]

    
    
    def _updateMetaForRename(self, new_path: Union[str, Path]):
        &#34;&#34;&#34;
        Updates the metadata and description files&#39; paths for the current QuetzalFile
        instance to reflect a change in the file or directory&#39;s name (rename action).

        This method is invoked internally to handle the renaming of metadata and description
        files associated with the QuetzalFile, ensuring consistency within the filesystem.

        Args:
            new_path (Union[str, Path]): The new path (name) for the file or directory, reflecting the rename.
        &#34;&#34;&#34;
        orig_path_full = self._metadata_dir / self._path
        new_path_full = self._metadata_dir / new_path
        
        ## New Directory if needed
        if self._type == FileType.DIRECTORY:
            if orig_path_full.exists():
                os.rename(orig_path_full, new_path_full)
            
        ## Rename Metadata
        metadata_path = self._getMetaDataPath(orig_path_full)
        new_metadata_path = self._getMetaDataPath(new_path_full)
        if metadata_path.exists():
            os.rename(metadata_path, new_metadata_path)
        else:
            with open(new_metadata_path, &#34;w&#34;) as file:
                file.write(
                    self.PROJECT_DEFAULT_META
                    if self._type == FileType.DIRECTORY
                    else self.FILE_DEFAULT_META
                )

        ## Rename Description
        description_path = self._getDescriptionPath(orig_path_full)
        new_description_path = self._getDescriptionPath(new_path_full)
        if description_path.exists():
            os.rename(description_path, new_description_path)
        else:
            with open(new_description_path, &#34;w&#34;) as file:
                file.write(
                    self.PROJECT_DEFAULT_DESCRIPTION
                    if self._type == FileType.DIRECTORY
                    else self.FILE_DEFAULT_DESCRIPTION
                )
    
    
    def _rename(self, new_file_name: Union[str, Path]) -&gt; str:
        &#34;&#34;&#34;
        Renames the current QuetzalFile (file or directory) to the new specified name and updates
        the metadata accordingly.
        
        For given new_file_name, only the name of the file will be considered. Parent_name, and suffix of the name
        will be modified to match the original file.

        Args:
            new_file_name (Union[str, Path]): The new name for the file or directory.

        Returns:
            A confirmation message indicating the successful rename.
        &#34;&#34;&#34;
        
        new_file_name = Path(new_file_name)
        assert (
            self._mode == AccessMode.OWNER or self._permission == Permission.FULL_WRITE
        )
        assert new_file_name.stem not in reserved_names

        debug(f&#34;\n\n\t{self.name} called on rename {new_file_name}\n&#34;)

        # Validate suffix
        if new_file_name.suffix != self._path.suffix:
            new_file_name = Path(new_file_name.name + self._path.suffix)

        # Rename
        new_path = self._path.parent / new_file_name
        new_path_abs = self._root_dir / new_path
        if new_path_abs.exists():
            raise FileExistsError(
                f&#39;File/directory with name &#34;{new_file_name}&#34; already exist at the destination.&#39;
            )
        os.rename(self._abs_path, new_path_abs)
        self._updateMetaForRename(new_path=new_path)

        org_name = self.name
        self._path = new_path
        return f&#39;&#34;{org_name}&#34; renamed to &#34;{self.name}&#34;&#39;


    def _updateMetaForNewFile(
        self, target_path: Path, file_name: Path, meta_data: str, description: str, isDir: bool=False
    ):
        &#34;&#34;&#34;
        Creates and updates the metadata and description for a new file or directory
        that is being added to the filesystem.

        Args:
            target_path (Path): The target path where the new file or directory is located.
            file_name (Path): The name of the new file or directory.
            meta_data (str): The metadata to be written for the new file or directory.
            description (str): The description to be written for the new file or directory.
            isDir (bool): A flag indicating whether the new entity is a directory. Defaults to False.
        &#34;&#34;&#34;
        # Crate New Meta Data, Description, and Directory
        new_file_metadata = self._metadata_dir / target_path / file_name
        if isDir:
            os.makedirs(new_file_metadata, exist_ok=True)

        new_file_metadata_path = self._getMetaDataPath(new_file_metadata)
        with open(new_file_metadata_path, &#34;w&#34;) as file:
            file.write(meta_data)

        new_file_description_path = self._getDescriptionPath(new_file_metadata)
        with open(new_file_description_path, &#34;w&#34;) as file:
            file.write(description)


    def _newDirectory(self, dir_name: Union[str, Path]) -&gt; str:
        &#34;&#34;&#34;
        Creates a new directory under the current QuetzalFile path and updates the metadata and
        description for it.

        Args:
            dir_name (Union[str, Path]): The name of the new directory to create.

        Returns:
            A confirmation message indicating the successful creation of the directory.
        &#34;&#34;&#34;
        dir_name = Path(dir_name)
        assert (
            self._mode == AccessMode.OWNER or self._permission != Permission.READ_ONLY
        )
        assert self._type == FileType.DIRECTORY
        assert dir_name.stem not in reserved_names

        debug(f&#34;\n\n\t{self.name} called on New dir {dir_name}\n&#34;)
        
        new_dir_path = self._root_dir / self._path / dir_name
        if new_dir_path.exists():
            raise FileExistsError(
                f&#39;Directory with name &#34;{dir_name}&#34; already exist at the destination.&#39;
            )
        os.makedirs(new_dir_path, exist_ok=False)

        self._updateMetaForNewFile(
            self._path,
            dir_name,
            self.PROJECT_DEFAULT_META + &#34;CreatedBy::= &#34; + self._user.id + &#34;\n&#34;,
            self.PROJECT_DEFAULT_DESCRIPTION,
            isDir=True
        )

        return f&#39;&#34;{dir_name}&#34; Created&#39;
    

    def _upload(self, uploaded_files: Union[str, Path]) -&gt; str:
        &#34;&#34;&#34;
        Uploads and saves the specified files to the current QuetzalFile directory, updating
        the metadata for each uploaded file.
        
        The method should fail when called on QuetzalFile with &#34;File&#34; filetype.

        Args:
            uploaded_files (Union[str, Path]): The files to be uploaded.

        Returns:
            A confirmation message indicating the number of files successfully uploaded.
        &#34;&#34;&#34;
        assert self._mode == AccessMode.OWNER or self._permission != Permission.READ_ONLY
        assert self._type == FileType.DIRECTORY
        
        for uploaded_file in uploaded_files:
            assert Path(uploaded_file.name).stem not in reserved_names
            debug(f&#34;\n\n\t{self.name} called on upload {uploaded_file.name}\n&#34;)

            dest: Path = self._root_dir / self._path / uploaded_file.name
            orig_name = dest
            start_num = 0
            while dest.exists():
                dest = appendText(orig_name, f&#34;_{start_num}&#34;)
                start_num += 1

            with open(dest, mode=&#34;wb&#34;) as w:
                w.write(uploaded_file.getvalue())

            self._updateMetaForNewFile(
                self._path,
                dest.name,
                self.FILE_DEFAULT_META + &#34;CreatedBy::= &#34; + self._user.id + &#34;\n&#34;,
                self.FILE_DEFAULT_DESCRIPTION,
            )

        return f&#34;{len(uploaded_files)} files successfully uploaded&#34;


    def _updateMetaForShare(self, shared: Visibility, permission: Permission):
        &#34;&#34;&#34;
        Updates the metadata for the QuetzalFile (file or directory) to reflect new sharing settings,
        including visibility and permissions.

        Args:
            shared (Visibility): The new visibility setting for the file or directory.
            permission (Permission): The new permission setting for the file or directory.
        &#34;&#34;&#34;
        metadata_path = self.getMetaDataPath(self._path)
        if os.path.exists(metadata_path):
            with open(metadata_path, &#34;r+&#34;) as file:
                metadata = file.read()
                metadata = metadata.replace(
                    f&#34;Visibility::= {self._visibility.value}&#34;,
                    f&#34;Visibility::= {shared.value}&#34;,
                )
                metadata = metadata.replace(
                    f&#34;Permission::= {self._permission.value}&#34;,
                    f&#34;Permission::= {permission.value}&#34;,
                )
                file.seek(0)
                file.write(metadata)
                file.truncate()

        self._visibility = shared
        self._permission = permission


    def _share(self, shared: Visibility, permission: Permission) -&gt; str:
        &#34;&#34;&#34;
        Applies new sharing settings to the file or directory, affecting its visibility
        and access permissions, and updates the metadata accordingly.

        Args:
            shared (Visibility): The new visibility setting.
            permission (Permission): The new access permission setting.

        Returns:
            A confirmation message indicating the updated sharing settings.
        &#34;&#34;&#34;
        assert (
            self._mode == AccessMode.OWNER or self._permission == Permission.FULL_WRITE
        )

        if shared == self._visibility and permission == self._permission:
            return None

        debug(f&#34;\n\n\t{self.name} called on share {shared}:{permission}\n&#34;)

        self._updateMetaForShare(shared, permission)

        # If the QuetzalFile is a directory, apply the changes to all sub-projects and video files
        if self._type == FileType.DIRECTORY:
            for subfile in self.iterdir():
                subfile._updateMetaForShare(shared, permission)

        return f&#39;&#34;{self.name}&#34; Sharing Setting Updated&#39;

    def _updateMetaForDelete(self):
        &#34;&#34;&#34;
        Cleans up the metadata and description files associated with the file or directory
        that is being deleted.
        &#34;&#34;&#34;
        orig_path_full = self._metadata_dir / self._path
        metadata_path = self._getMetaDataPath(orig_path_full)
        description_path = self._getDescriptionPath(orig_path_full)

        if metadata_path.exists():
            os.remove(metadata_path)
        if description_path.exists():
            os.remove(description_path)
        if orig_path_full.exists():
            shutil.rmtree(orig_path_full)

    def _delete(self) -&gt; str:
        &#34;&#34;&#34;
        Deletes the current file or directory and cleans up its associated metadata
        and description files.

        Returns:
            A confirmation message indicating the successful deletion.
        &#34;&#34;&#34;
        assert (
            self._mode == AccessMode.OWNER or self._permission == Permission.FULL_WRITE
        )

        debug(f&#34;\n\n\t{self.name} called on delete\n&#34;)

        if self._type == FileType.FILE:
            os.remove(self._root_dir / self._path)
        else:  # For directories
            shutil.rmtree(self._root_dir / self._path)

        self._updateMetaForDelete()

        return f&#39;&#34;{self.name}&#34; Deleted&#39;

    def _updateMetaForAnalyze(self, new_progress: AnalysisProgress):
        &#34;&#34;&#34;
        Updates the metadata for the file to reflect a new state of analysis progress.

        Args:
            new_progress (AnalysisProgress): The new analysis progress state to update the metadata with.
        &#34;&#34;&#34;
        
        orig_path_full = self._metadata_dir / self._path
        metadata_path = self._getMetaDataPath(orig_path_full)

        if os.path.exists(metadata_path):
            with open(metadata_path, &#34;r+&#34;) as file:
                metadata = file.read()
                metadata = metadata.replace(
                    f&#34;AnalysisProgress::= {self._analysis_progress.value}&#34;,
                    f&#34;AnalysisProgress::= {new_progress.value}&#34;,
                )
                file.seek(0)
                file.write(metadata)
                file.truncate()

    def _syncAnalysisState(self):
        &#34;&#34;&#34;
        Synchronizes the analysis state of the file with the current status in the
        analysis engine or database, updating the metadata as necessary.
        &#34;&#34;&#34;
        assert self._type == FileType.FILE
        
        return

    def _analyze(self, option: AnalysisProgress, engine=None, device=None) -&gt; str:
        &#34;&#34;&#34;
        Initiat es analysis of the video file with the specified options, using the
        given analysis engine and device.

        Args:
            option (AnalysisProgress): The desired level of analysis to be performed.
            engine: The analysis engine to use for the analysis. Defaults to None.
            device: The cuda device to perform the analysis on. Defaults to None.

        Returns:
            A confirmation message indicating the completion of the analysis.
        &#34;&#34;&#34;     
        
        assert (
            self._mode == AccessMode.OWNER or self._permission != Permission.READ_ONLY
        )
        debug(f&#34;\n\t{self.name} called on analyze {option}\n&#34;)

        if option == None:
            return None

        return f&#39;&#34;{self.name}&#34; Analysis Done&#39;


    def _editDescription(self, value: str) -&gt; str:
        &#34;&#34;&#34;
        Updates the description for the file or directory with the given value.

        Args:
            value (str): The new description to be applied to the file or directory.

        Returns:
            A confirmation message indicating the successful update of the description.
        &#34;&#34;&#34;
        assert (
            self._mode == AccessMode.OWNER or self._permission == Permission.FULL_WRITE
        )

        debug(f&#34;\n\t{self.name} called on editMetaData {value}\n&#34;)
        description_file_path = self.getDescriptionPath(self._path)

        # Overwrite the existing description with the new value
        with open(description_file_path, &#34;w&#34;) as file:
            file.write(value)

        return f&#39;&#34;{self.name}&#34; Edit Success&#39;

    
    def _updateMetaForCopy(self, dest: Path):
        &#34;&#34;&#34;
        Updates the metadata for a file or directory when it is copied to a new location.

        Args:
            dest: The destination path where the file or directory has been copied.
        &#34;&#34;&#34;
        source_metadata = self._metadata_dir / self._path
        dest_metadata = self._metadata_dir / dest
        
        if self._type == FileType.DIRECTORY:
            shutil.copytree(source_metadata, dest_metadata)
        
        source_metadata_path = self._getMetaDataPath(source_metadata)
        dest_metadata_path = self._getMetaDataPath(dest_metadata)
        shutil.copy2(source_metadata_path, dest_metadata_path)

        source_desc_path = self._getDescriptionPath(source_metadata)
        dest_desc_path = self._getDescriptionPath(dest_metadata)
        shutil.copy2(source_desc_path, dest_desc_path)
        
    
    def _copy(self, dest_dir: &#34;QuetzalFile&#34;) -&gt; str:
        &#34;&#34;&#34;
        Copies the current file or directory to a new destination within the Quetzal file system, updating metadata
        accordingly.

        This method copies the file/directory represented by this instance to the specified destination directory,
        also handling metadata and description files to reflect the new location.

        Args:
            dest_dir (QueztalFile): The destination `QuetzalFile` directory where this file/directory is to be copied.

        Returns:
            A string message indicating the successful copy operation.
        &#34;&#34;&#34;
        debug(f&#34;{self.name} called on copy to &#34;, dest_dir)
        assert dest_dir._type == FileType.DIRECTORY

        # Adjust Destination relative Path
        destination_path = dest_dir._abs_path
        dest_dir: Path = destination_path.relative_to(self._root_dir.absolute())

        # Rename destination if it is duplicates
        dest = getCopyName(self._root_dir / dest_dir / self._path.name)
        
        # Copy target File
        source = self._root_dir / self._path
        if self._type == FileType.DIRECTORY:
            shutil.copytree(source, dest)
        else:
            shutil.copy2(source, dest)
        
        # Update metaData
        self._updateMetaForCopy(dest.relative_to(self._root_dir))
        
        return f&#39;&#34;{self.name}&#34; copied to &#34;{dest_dir}&#34;&#39;
            

    def _updateMetaForMove(self, dest_dir: Path):
        &#34;&#34;&#34;
        Updates the metadata for a file or directory when it is moved to a new location.

        This includes moving the metadata and description files to reflect the new file path and updating any
        directory-specific metadata if the moved entity is a directory.

        Args:
            dest_dir (Path): The destination path where the file or directory has been moved.
        &#34;&#34;&#34;
        source_metadata = self._metadata_dir / self._path
        
        if self._type == FileType.DIRECTORY:
            dest_metadata = self._metadata_dir / dest_dir
            shutil.move(source_metadata, dest_metadata)
        else:
            dest_metadata = self._metadata_dir / dest_dir / self._path.name

        source_metadata_path = self._getMetaDataPath(source_metadata)
        dest_metadata_path = self._getMetaDataPath(dest_metadata)
        shutil.move(source_metadata_path, dest_metadata_path)

        source_desc_path = self._getDescriptionPath(source_metadata)
        dest_desc_path = self._getDescriptionPath(dest_metadata)
        shutil.move(source_desc_path, dest_desc_path)
        
    
    def _move(self, dest_dir: &#34;QuetzalFile&#34;) -&gt; str:
        &#34;&#34;&#34;
        Moves the current file or directory to a new destination within the Quetzal file system, updating metadata
        accordingly.

        This method moves the file/directory represented by this instance to the specified destination directory,
        handling metadata and description files to reflect the new location. It also ensures that the move does not
        violate any system rules, such as moving into a subdirectory of itself.

        Args:
            dest_dir (QuetzalFile): The destination `QuetzalFile` directory where this file/directory is to be moved.

        Returns:
            A string message indicating the successful move operation.
        &#34;&#34;&#34;
        assert (
            self._mode == AccessMode.OWNER or self._permission == Permission.FULL_WRITE
        )
        debug(f&#34;{self.name} called on move to &#34;, dest_dir)

         # Adjust Destination relative Path
        destination_path = dest_dir._abs_path
        dest_dir: Path = destination_path.relative_to(self._root_dir.absolute())

        # Varify destination is valid
        source = self._root_dir / self._path
        dest = self._root_dir / dest_dir

        if (dest / self._path.name).exists():
            raise FileExistsError(
                f&#39;File/directory with name &#34;{self._path.name}&#34; already exist at the destination.&#39;
            )

        if dest.is_relative_to(source):
            raise Exception(f&#34;You can&#39;t move a directory into itself.&#34;)

        # Move file, metadata, and description
        if self._type == FileType.DIRECTORY:
            shutil.move(source, dest)
        else:
            dest = dest / self._path.name
            shutil.move(source, dest)
        
        # Update metaData
        self._updateMetaForMove(dest_dir)
        
        return f&#39;&#34;{self.name}&#34; moved to &#34;{dest_dir}&#34;&#39;
    

    @staticmethod
    def _getMetaDataPath(path: Path) -&gt; Path:
        &#34;&#34;&#34;
        Constructs and returns the full path to the metadata file for a given absolute file or directory path.

        Args:
            path (Path): The path to the file or directory whose metadata path is to be constructed.

        Returns:
            The full `Path` object pointing to the metadata file.
        &#34;&#34;&#34;
        return path.with_name(path.name + META_SUFFIX)

    @staticmethod
    def _getDescriptionPath(path: Path) -&gt; Path:
        &#34;&#34;&#34;
        Constructs and returns the full path to the description file for a given file or directory path.

        Args:
            path (Path): The path to the file or directory whose description path is to be constructed.

        Returns:
            The full `Path` object pointing to the description file.
        &#34;&#34;&#34;
        return path.with_name(path.name + INFO_SUFFIX)

    def getMetaDataPath(self, path: Path) -&gt; Path:
        &#34;&#34;&#34;
        Retrieves the full path to the metadata file associated with a given file or directory path, 
        based on current QuetzalFile configuration.

        Args:
            path (Path): The path to the file or directory whose metadata file path is to be retrieved.

        Returns:
            The full `Path` object pointing to the metadata file.
        &#34;&#34;&#34;
        return self._getMetaDataPath(self._metadata_dir / path)

    def getDescriptionPath(self, path: Path):
        &#34;&#34;&#34;
        Retrieves the full path to the description file associated with a given file or directory path, 
        based on current QuetzalFile configuration.

        Args:
            path (Path): The path to the file or directory whose description file path is to be retrieved.

        Returns:
            The full `Path` object pointing to the description file.
        &#34;&#34;&#34;
        return self._getDescriptionPath(self._metadata_dir / path)

    def _makeDefaultDescription(self, path: Union[str, Path]):
        &#34;&#34;&#34;
        Creates a default description file for a file or directory if one does not already exist.

        This method is typically called when a new file or directory is added to ensure that it has a basic description.

        Args:
            path: The path to the file or directory for which a default description is to be created.
        &#34;&#34;&#34;
        if self._type == FileType.DIRECTORY:
            default_content = self.PROJECT_DEFAULT_DESCRIPTION
        else:
            default_content = self.FILE_DEFAULT_DESCRIPTION

        with open(path, &#34;w&#34;) as file:
            file.write(default_content)

    def getDescription(self) -&gt; str:
        &#34;&#34;&#34;
        Retrieves the description of the current file or directory.

        If a description file does not exist, a default description is created and then retrieved.

        Returns:
            The description text of the file or directory.
        &#34;&#34;&#34;
        description_file_path = self.getDescriptionPath(self._path)

        # if not os.path.exists(description_file_path):
        if not description_file_path.exists():
            self._makeDefaultDescription(description_file_path)

        with open(description_file_path, &#34;r&#34;) as file:
            return file.read()

    def __format__(self, __format_spec: str) -&gt; str:
        return (
            &#34;\n&#34;.join(
                [
                    &#34;&lt;QueztalFile::=&#34; + str(self._path) + &#34;&gt;&#34;,
                    &#34;type::= &#34; + str(self._type),
                    &#34;createdby::= &#34; + str(self._created_by),
                    &#34;user::= &#34; + str(self._owner),
                    &#34;permission::= &#34; + str(self._permission),
                    &#34;visibility::= &#34; + str(self._visibility),
                    &#34;analysis_progress::= &#34; + str(self._analysis_progress),
                ]
            )
            + &#34;\n&#34;
        )

    def __repr__(self) -&gt; str:
        return (
            &#34;\n&#34;.join(
                [
                    &#34;&lt;QueztalFile::=&#34; + str(self._path) + &#34;&gt;&#34;,
                    &#34;type::= &#34; + str(self._type),
                    &#34;createdby::= &#34; + str(self._created_by),
                    &#34;user::= &#34; + str(self._owner),
                    &#34;permission::= &#34; + str(self._permission),
                    &#34;visibility::= &#34; + str(self._visibility),
                    &#34;analysis_progress::= &#34; + str(self._analysis_progress),
                ]
            )
            + &#34;\n&#34;
        )</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="quetzal.dtos.video.Video" href="video.html#quetzal.dtos.video.Video">Video</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="quetzal.dtos.dtos.QuetzalFile.FILE_DEFAULT_DESCRIPTION"><code class="name">var <span class="ident">FILE_DEFAULT_DESCRIPTION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile.FILE_DEFAULT_META"><code class="name">var <span class="ident">FILE_DEFAULT_META</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile.PROJECT_DEFAULT_DESCRIPTION"><code class="name">var <span class="ident">PROJECT_DEFAULT_DESCRIPTION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile.PROJECT_DEFAULT_META"><code class="name">var <span class="ident">PROJECT_DEFAULT_META</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile.ROOT_DESCRIPTOIN"><code class="name">var <span class="ident">ROOT_DESCRIPTOIN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile.ROOT_META"><code class="name">var <span class="ident">ROOT_META</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile.USER_ROOT_DESCRIPTION"><code class="name">var <span class="ident">USER_ROOT_DESCRIPTION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile.USER_ROOT_META"><code class="name">var <span class="ident">USER_ROOT_META</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="quetzal.dtos.dtos.QuetzalFile._getDescriptionPath"><code class="name flex">
<span>def <span class="ident">_getDescriptionPath</span></span>(<span>path:pathlib.Path) >pathlib.Path</span>
</code></dt>
<dd>
<div class="desc"><p>Constructs and returns the full path to the description file for a given file or directory path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>Path</code></dt>
<dd>The path to the file or directory whose description path is to be constructed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The full <code>Path</code> object pointing to the description file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def _getDescriptionPath(path: Path) -&gt; Path:
    &#34;&#34;&#34;
    Constructs and returns the full path to the description file for a given file or directory path.

    Args:
        path (Path): The path to the file or directory whose description path is to be constructed.

    Returns:
        The full `Path` object pointing to the description file.
    &#34;&#34;&#34;
    return path.with_name(path.name + INFO_SUFFIX)</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile._getMetaDataPath"><code class="name flex">
<span>def <span class="ident">_getMetaDataPath</span></span>(<span>path:pathlib.Path) >pathlib.Path</span>
</code></dt>
<dd>
<div class="desc"><p>Constructs and returns the full path to the metadata file for a given absolute file or directory path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>Path</code></dt>
<dd>The path to the file or directory whose metadata path is to be constructed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The full <code>Path</code> object pointing to the metadata file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def _getMetaDataPath(path: Path) -&gt; Path:
    &#34;&#34;&#34;
    Constructs and returns the full path to the metadata file for a given absolute file or directory path.

    Args:
        path (Path): The path to the file or directory whose metadata path is to be constructed.

    Returns:
        The full `Path` object pointing to the metadata file.
    &#34;&#34;&#34;
    return path.with_name(path.name + META_SUFFIX)</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile._instantiateFile"><code class="name flex">
<span>def <span class="ident">_instantiateFile</span></span>(<span>path:pathlib.Path, root_dir:pathlib.Path, metadata_dir:pathlib.Path, user:<a title="quetzal.dtos.dtos.User" href="#quetzal.dtos.dtos.User">User</a>, home:pathlib.Path, metadata:dict[str,typing.Union[<a title="quetzal.dtos.dtos.Permission" href="#quetzal.dtos.dtos.Permission">Permission</a>,<a title="quetzal.dtos.dtos.Visibility" href="#quetzal.dtos.dtos.Visibility">Visibility</a>,<a title="quetzal.dtos.dtos.FileType" href="#quetzal.dtos.dtos.FileType">FileType</a>,<a title="quetzal.dtos.dtos.AnalysisProgress" href="#quetzal.dtos.dtos.AnalysisProgress">AnalysisProgress</a>,quetzal.dtos.dtos.CreatedBy,quetzal.dtos.dtos.SpecificType]], parent:<a title="quetzal.dtos.dtos.QuetzalFile" href="#quetzal.dtos.dtos.QuetzalFile">QuetzalFile</a>) ><a title="quetzal.dtos.dtos.QuetzalFile" href="#quetzal.dtos.dtos.QuetzalFile">QuetzalFile</a></span>
</code></dt>
<dd>
<div class="desc"><p>Instantiate a file into "Specific Type", one of subclass of QuetzalFile.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>Path</code></dt>
<dd>The path of the file or directory, relative to the root directory.</dd>
<dt><strong><code>root_dir</code></strong> :&ensp;<code>Path</code></dt>
<dd>The root directory path of the Quetzal file system.</dd>
<dt><strong><code>metadata_dir</code></strong> :&ensp;<code>Path</code></dt>
<dd>The directory path where metadata files are stored.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a title="quetzal.dtos.dtos.User" href="#quetzal.dtos.dtos.User">User</a></code></dt>
<dd>The user who is interacting with the file.</dd>
<dt><strong><code>home</code></strong> :&ensp;<code>Path</code></dt>
<dd>The base home directory path (relative to rood directory). Defaults to "./".</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>Optional[Dict[str, MetaData]]</code></dt>
<dd>The metadata associated with the file.</dd>
<dt><strong><code>parent</code></strong> :&ensp;<code>Optional[<a title="quetzal.dtos.dtos.QuetzalFile" href="#quetzal.dtos.dtos.QuetzalFile">QuetzalFile</a>]</code></dt>
<dd>The parent directory of the current file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Instance of "Specific Type" (subclass of QuetzalFile)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def _instantiateFile(
    path: Path,
    root_dir: Path,
    metadata_dir: Path,
    user: User,
    home: Path,
    metadata: dict[str, MetaData],
    parent: &#39;QuetzalFile&#39;,
) -&gt; &#34;QuetzalFile&#34;:
    &#34;&#34;&#34;
    Instantiate a file into &#34;Specific Type&#34;, one of subclass of QuetzalFile.
    
    Args:
        path (Path): The path of the file or directory, relative to the root directory.
        root_dir (Path): The root directory path of the Quetzal file system.
        metadata_dir (Path): The directory path where metadata files are stored.
        user (User): The user who is interacting with the file.
        home (Path): The base home directory path (relative to rood directory). Defaults to &#34;./&#34;.
        metadata (Optional[Dict[str, MetaData]]): The metadata associated with the file.
        parent (Optional[QuetzalFile]): The parent directory of the current file.
    
    Returns:
        Instance of &#34;Specific Type&#34; (subclass of QuetzalFile)
    &#34;&#34;&#34;
    
    specific_file_class = None
    specific_type = metadata.get(&#34;SpecificType&#34;, None)
    
    if specific_type:
        module = importlib.import_module(f&#34;quetzal.dtos.{specific_type.lower()}&#34;)
        specific_file_class = getattr(module, specific_type)

    if specific_file_class and issubclass(specific_file_class, QuetzalFile):
        return specific_file_class(
            path=path,
            root_dir=root_dir,
            metadata_dir=metadata_dir,
            user=user,
            home=home,
            metadata=metadata,
            parent=parent,
        )
    else:
        return QuetzalFile(
            path=path,
            root_dir=root_dir,
            metadata_dir=metadata_dir,
            user=user,
            home=home,
            metadata=metadata,
            parent=parent
        )</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile._loadMetaData"><code class="name flex">
<span>def <span class="ident">_loadMetaData</span></span>(<span>metadata_path:pathlib.Path) >dict[str,typing.Union[<a title="quetzal.dtos.dtos.Permission" href="#quetzal.dtos.dtos.Permission">Permission</a>,<a title="quetzal.dtos.dtos.Visibility" href="#quetzal.dtos.dtos.Visibility">Visibility</a>,<a title="quetzal.dtos.dtos.FileType" href="#quetzal.dtos.dtos.FileType">FileType</a>,<a title="quetzal.dtos.dtos.AnalysisProgress" href="#quetzal.dtos.dtos.AnalysisProgress">AnalysisProgress</a>,quetzal.dtos.dtos.CreatedBy,quetzal.dtos.dtos.SpecificType]]</span>
</code></dt>
<dd>
<div class="desc"><p>Load Queztalfile metadata from the given path</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>metadata_dir</code></strong> :&ensp;<code>Path</code></dt>
<dd>The directory path where metadata files are stored.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>dict[str, MetaData]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def _loadMetaData(metadata_path: Path) -&gt; dict[str, MetaData]:
    &#34;&#34;&#34;
    Load Queztalfile metadata from the given path
    
    Args:
        metadata_dir (Path): The directory path where metadata files are stored.
    
    Returns:
        dict[str, MetaData]
    &#34;&#34;&#34;
    if not os.path.exists(metadata_path):
        raise FileNotFoundError

    with open(metadata_path, &#34;r&#34;) as file:
        data = file.read().splitlines()
    metadata = {
        line.split(&#34;::=&#34;)[0].strip(): line.split(&#34;::=&#34;)[1].strip()
        for line in data
        if line.strip()
    }

    metadata[&#34;CreatedBy&#34;] = CreatedBy(User(metadata.get(&#34;CreatedBy&#34;, None)))
    metadata[&#34;FileType&#34;] = FileType(metadata.get(&#34;FileType&#34;, &#34;file&#34;))
    metadata[&#34;Visibility&#34;] = Visibility(metadata.get(&#34;Visibility&#34;, &#34;private&#34;))
    metadata[&#34;AnalysisProgress&#34;] = AnalysisProgress(
        metadata.get(&#34;AnalysisProgress&#34;, &#34;none&#34;)
    )
    metadata[&#34;Permission&#34;] = Permission(metadata.get(&#34;Permission&#34;, &#34;full_write&#34;))
    metadata[&#34;SpecificType&#34;] = SpecificType(metadata.get(&#34;SpecificType&#34;, None))

    return metadata</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile.fromFile"><code class="name flex">
<span>def <span class="ident">fromFile</span></span>(<span>file:<a title="quetzal.dtos.dtos.QuetzalFile" href="#quetzal.dtos.dtos.QuetzalFile">QuetzalFile</a>, path:Union[str,pathlib.Path], home:Union[str,pathlib.Path,ForwardRef(None)]=None) ><a title="quetzal.dtos.dtos.QuetzalFile" href="#quetzal.dtos.dtos.QuetzalFile">QuetzalFile</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new instance of QuetzalFile based on an existing instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong></dt>
<dd>The QuetzalFile instance to base the new instance on.</dd>
<dt><strong><code>path</code></strong></dt>
<dd>The path for the new QuetzalFile instance. Actual path relative to the root_dir will be "./home/path".</dd>
<dt><strong><code>home</code></strong></dt>
<dd>The home directory for the new instance. If None, the home of the 'file' is used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new QuetzalFile instance based on the provided file and path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def fromFile(file: &#34;QuetzalFile&#34;, path: Union[str, Path], home: Optional[Union[str, Path]]=None) -&gt; &#34;QuetzalFile&#34;:
    &#34;&#34;&#34;
    Creates a new instance of QuetzalFile based on an existing instance.

    Args:
        file: The QuetzalFile instance to base the new instance on.
        path: The path for the new QuetzalFile instance. Actual path relative to the root_dir will be &#34;./home/path&#34;.
        home: The home directory for the new instance. If None, the home of the &#39;file&#39; is used.

    Returns:
        A new QuetzalFile instance based on the provided file and path.
    &#34;&#34;&#34;
    
    if home is None:    
        home = file._home
    else:
        home = Path(home)
    return QuetzalFile(
        path=home / path,
        root_dir=file._root_dir,
        metadata_dir=file._metadata_dir,
        user=file._user,
        home=home
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="quetzal.dtos.dtos.QuetzalFile._abs_path"><code class="name">var <span class="ident">_abs_path</span> :pathlib.Path</code></dt>
<dd>
<div class="desc"><p>Full absolute path of the file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def _abs_path(self) -&gt; Path:
    &#34;&#34;&#34;Full absolute path of the file&#34;&#34;&#34;
    return (self._root_dir / self._path).absolute()</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile.analysis_progress"><code class="name">var <span class="ident">analysis_progress</span> :<a title="quetzal.dtos.dtos.AnalysisProgress" href="#quetzal.dtos.dtos.AnalysisProgress">AnalysisProgress</a></code></dt>
<dd>
<div class="desc"><p>The current progress of any ongoing analysis.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def analysis_progress(self) -&gt; AnalysisProgress:
    &#34;&#34;&#34;The current progress of any ongoing analysis.&#34;&#34;&#34;
    return self._analysis_progress</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile.createdBy"><code class="name">var <span class="ident">createdBy</span> :<a title="quetzal.dtos.dtos.User" href="#quetzal.dtos.dtos.User">User</a></code></dt>
<dd>
<div class="desc"><p>The user who created the file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def createdBy(self) -&gt; User:
    &#34;&#34;&#34;The user who created the file.&#34;&#34;&#34;
    return self._created_by.id</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile.full_path"><code class="name">var <span class="ident">full_path</span> :pathlib.Path</code></dt>
<dd>
<div class="desc"><p>The full filesystem path to the file or directory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def full_path(self) -&gt; Path:
    &#34;&#34;&#34;The full filesystem path to the file or directory.&#34;&#34;&#34;
    return self._root_dir / self._path</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile.home"><code class="name">var <span class="ident">home</span> :pathlib.Path</code></dt>
<dd>
<div class="desc"><p>The base home directory path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def home(self) -&gt; Path:
    &#34;&#34;&#34;The base home directory path.&#34;&#34;&#34;
    return self._home</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile.mode"><code class="name">var <span class="ident">mode</span> :<a title="quetzal.dtos.dtos.AccessMode" href="#quetzal.dtos.dtos.AccessMode">AccessMode</a></code></dt>
<dd>
<div class="desc"><p>The access mode, indicating if the current user is the OWNER or OTHERS.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mode(self) -&gt; AccessMode:
    &#34;&#34;&#34;The access mode, indicating if the current user is the OWNER or OTHERS.&#34;&#34;&#34;
    return self._mode</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile.name"><code class="name">var <span class="ident">name</span> :str</code></dt>
<dd>
<div class="desc"><p>The name of the file or directory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;The name of the file or directory.&#34;&#34;&#34;
    return self._path.name</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile.path"><code class="name">var <span class="ident">path</span> :pathlib.Path</code></dt>
<dd>
<div class="desc"><p>Relative path to the file or directory from the "home" directory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def path(self) -&gt; Path:
    &#34;&#34;&#34;Relative path to the file or directory from the &#34;home&#34; directory.&#34;&#34;&#34;
    return self._path.relative_to(self._home)</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile.permission"><code class="name">var <span class="ident">permission</span> :<a title="quetzal.dtos.dtos.Permission" href="#quetzal.dtos.dtos.Permission">Permission</a></code></dt>
<dd>
<div class="desc"><p>The access permissions of the file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def permission(self) -&gt; Permission:
    &#34;&#34;&#34;The access permissions of the file.&#34;&#34;&#34;
    return self._permission</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile.type"><code class="name">var <span class="ident">type</span> :<a title="quetzal.dtos.dtos.FileType" href="#quetzal.dtos.dtos.FileType">FileType</a></code></dt>
<dd>
<div class="desc"><p>The type of the file, either FILE or DIRECTORY.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self) -&gt; FileType:
    &#34;&#34;&#34;The type of the file, either FILE or DIRECTORY.&#34;&#34;&#34;
    return self._type</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile.user"><code class="name">var <span class="ident">user</span> :<a title="quetzal.dtos.dtos.User" href="#quetzal.dtos.dtos.User">User</a></code></dt>
<dd>
<div class="desc"><p>The current user interacting with the file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def user(self) -&gt; User:
    &#34;&#34;&#34;The current user interacting with the file.&#34;&#34;&#34;
    return self._user.id</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile.visibility"><code class="name">var <span class="ident">visibility</span> :<a title="quetzal.dtos.dtos.Visibility" href="#quetzal.dtos.dtos.Visibility">Visibility</a></code></dt>
<dd>
<div class="desc"><p>The visibility setting of the file, either SHARED or PRIVATE.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def visibility(self) -&gt; Visibility:
    &#34;&#34;&#34;The visibility setting of the file, either SHARED or PRIVATE.&#34;&#34;&#34;
    return self._visibility</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="quetzal.dtos.dtos.QuetzalFile.__eq__"><code class="name flex">
<span>def <span class="ident">__eq__</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Return self==value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __eq__(self, other):
    match other:
        case QuetzalFile():
            return self._path == other._path
        case str():
            return self._path == other
        case _:
            return NotImplemented</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile.__format__"><code class="name flex">
<span>def <span class="ident">__format__</span></span>(<span>self, _QuetzalFile__format_spec:str) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Default object formatter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __format__(self, __format_spec: str) -&gt; str:
    return (
        &#34;\n&#34;.join(
            [
                &#34;&lt;QueztalFile::=&#34; + str(self._path) + &#34;&gt;&#34;,
                &#34;type::= &#34; + str(self._type),
                &#34;createdby::= &#34; + str(self._created_by),
                &#34;user::= &#34; + str(self._owner),
                &#34;permission::= &#34; + str(self._permission),
                &#34;visibility::= &#34; + str(self._visibility),
                &#34;analysis_progress::= &#34; + str(self._analysis_progress),
            ]
        )
        + &#34;\n&#34;
    )</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile.__hash__"><code class="name flex">
<span>def <span class="ident">__hash__</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return hash(self).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __hash__(self):
    return hash(str(self.path))</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, path:Union[str,pathlib.Path], root_dir:Union[str,pathlib.Path], metadata_dir:Union[str,pathlib.Path], user:Union[str,<a title="quetzal.dtos.dtos.User" href="#quetzal.dtos.dtos.User">User</a>]=None, home:Union[str,pathlib.Path]='./', metadata:Optional[dict[str,typing.Union[<a title="quetzal.dtos.dtos.Permission" href="#quetzal.dtos.dtos.Permission">Permission</a>,<a title="quetzal.dtos.dtos.Visibility" href="#quetzal.dtos.dtos.Visibility">Visibility</a>,<a title="quetzal.dtos.dtos.FileType" href="#quetzal.dtos.dtos.FileType">FileType</a>,<a title="quetzal.dtos.dtos.AnalysisProgress" href="#quetzal.dtos.dtos.AnalysisProgress">AnalysisProgress</a>,quetzal.dtos.dtos.CreatedBy,quetzal.dtos.dtos.SpecificType]]]=None, parent:<a title="quetzal.dtos.dtos.QuetzalFile" href="#quetzal.dtos.dtos.QuetzalFile">QuetzalFile</a>=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>Path</code></dt>
<dd>The path of the file or directory, relative to the root directory.</dd>
<dt><strong><code>root_dir</code></strong> :&ensp;<code>Path</code></dt>
<dd>The root directory path of the Quetzal file system.</dd>
<dt><strong><code>metadata_dir</code></strong> :&ensp;<code>Path</code></dt>
<dd>The directory path where metadata files are stored.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a title="quetzal.dtos.dtos.User" href="#quetzal.dtos.dtos.User">User</a></code></dt>
<dd>The user who is interacting with the file.</dd>
<dt><strong><code>home</code></strong> :&ensp;<code>Path</code></dt>
<dd>The base home directory path (relative to rood directory). Defaults to "./".</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>Optional[Dict[str, MetaData]]</code></dt>
<dd>The metadata associated with the file.</dd>
<dt><strong><code>parent</code></strong> :&ensp;<code>Optional[<a title="quetzal.dtos.dtos.QuetzalFile" href="#quetzal.dtos.dtos.QuetzalFile">QuetzalFile</a>]</code></dt>
<dd>The parent directory of the current file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __init__(
    self,
    path: Union[str, Path],  # path to the dir/file from root_dir
    root_dir: Union[str, Path],
    metadata_dir: Union[str, Path],
    user: Union[str, User] = User.GuestId,
    home: Union[str, Path] = &#34;./&#34;,
    metadata: Optional[dict[str, MetaData]] = None,
    parent: &#39;QuetzalFile&#39; = None,
):
    &#34;&#34;&#34;        
    Args:
        path (Path): The path of the file or directory, relative to the root directory.
        root_dir (Path): The root directory path of the Quetzal file system.
        metadata_dir (Path): The directory path where metadata files are stored.
        user (User): The user who is interacting with the file.
        home (Path): The base home directory path (relative to rood directory). Defaults to &#34;./&#34;.
        metadata (Optional[Dict[str, MetaData]]): The metadata associated with the file.
        parent (Optional[QuetzalFile]): The parent directory of the current file.
    &#34;&#34;&#34;
    self._path = Path(path)
    self._root_dir = Path(root_dir)
    self._metadata_dir = Path(metadata_dir)
    self._user = User(user)
    self._home = Path(home)
    self._parent = parent

    assert self._user != &#34;example&#34;

    if not (self.full_path).exists():
        if self._path == Path(self._user.id):
            os.makedirs(self.full_path, exist_ok=True)
            info_path = self.getDescriptionPath(self._path)
            info_path.write_text(self.USER_ROOT_DESCRIPTION)
            mata_path = self.getMetaDataPath(self._path)
            mata_path.write_text(self.USER_ROOT_META + &#34;CreatedBy::= admin\n&#34; )
        else:    
            raise FileNotFoundError(
                f&#39;File &#34;{self._root_dir / self._path}&#34; Do not Exist&#39;
            )

    if not self.getMetaDataPath(self._path).exists():
        raise FileNotFoundError(
            f&#39;Meta File &#34;{self.getMetaDataPath(self._path)}&#34; Do not Exist&#39;
        )

    if not self._path.is_relative_to(self._home):
        raise ValueError(f&#39;&#34;{path}&#34; is not relative to &#34;{home}&#34;&#39;)

    ## load_metadata
    self._parseMetadata(metadata)

    match self._path.parts:
        case [user_id, *_]:
            self._owner = User(user_id)
        case _:
            self._owner = User(ADMIN_ID)

    self._mode = (
        AccessMode.OWNER if self._owner == self._user else AccessMode.OTHERS
    )
    
    self._iterdir = None</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile.__repr__"><code class="name flex">
<span>def <span class="ident">__repr__</span></span>(<span>self) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Return repr(self).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __repr__(self) -&gt; str:
    return (
        &#34;\n&#34;.join(
            [
                &#34;&lt;QueztalFile::=&#34; + str(self._path) + &#34;&gt;&#34;,
                &#34;type::= &#34; + str(self._type),
                &#34;createdby::= &#34; + str(self._created_by),
                &#34;user::= &#34; + str(self._owner),
                &#34;permission::= &#34; + str(self._permission),
                &#34;visibility::= &#34; + str(self._visibility),
                &#34;analysis_progress::= &#34; + str(self._analysis_progress),
            ]
        )
        + &#34;\n&#34;
    )</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile._analyze"><code class="name flex">
<span>def <span class="ident">_analyze</span></span>(<span>self, option:<a title="quetzal.dtos.dtos.AnalysisProgress" href="#quetzal.dtos.dtos.AnalysisProgress">AnalysisProgress</a>, engine=None, device=None) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Initiat es analysis of the video file with the specified options, using the
given analysis engine and device.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>option</code></strong> :&ensp;<code><a title="quetzal.dtos.dtos.AnalysisProgress" href="#quetzal.dtos.dtos.AnalysisProgress">AnalysisProgress</a></code></dt>
<dd>The desired level of analysis to be performed.</dd>
<dt><strong><code>engine</code></strong></dt>
<dd>The analysis engine to use for the analysis. Defaults to None.</dd>
<dt><strong><code>device</code></strong></dt>
<dd>The cuda device to perform the analysis on. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A confirmation message indicating the completion of the analysis.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _analyze(self, option: AnalysisProgress, engine=None, device=None) -&gt; str:
    &#34;&#34;&#34;
    Initiat es analysis of the video file with the specified options, using the
    given analysis engine and device.

    Args:
        option (AnalysisProgress): The desired level of analysis to be performed.
        engine: The analysis engine to use for the analysis. Defaults to None.
        device: The cuda device to perform the analysis on. Defaults to None.

    Returns:
        A confirmation message indicating the completion of the analysis.
    &#34;&#34;&#34;     
    
    assert (
        self._mode == AccessMode.OWNER or self._permission != Permission.READ_ONLY
    )
    debug(f&#34;\n\t{self.name} called on analyze {option}\n&#34;)

    if option == None:
        return None

    return f&#39;&#34;{self.name}&#34; Analysis Done&#39;</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile._copy"><code class="name flex">
<span>def <span class="ident">_copy</span></span>(<span>self, dest_dir:<a title="quetzal.dtos.dtos.QuetzalFile" href="#quetzal.dtos.dtos.QuetzalFile">QuetzalFile</a>) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Copies the current file or directory to a new destination within the Quetzal file system, updating metadata
accordingly.</p>
<p>This method copies the file/directory represented by this instance to the specified destination directory,
also handling metadata and description files to reflect the new location.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dest_dir</code></strong> :&ensp;<code>QueztalFile</code></dt>
<dd>The destination <code><a title="quetzal.dtos.dtos.QuetzalFile" href="#quetzal.dtos.dtos.QuetzalFile">QuetzalFile</a></code> directory where this file/directory is to be copied.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A string message indicating the successful copy operation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _copy(self, dest_dir: &#34;QuetzalFile&#34;) -&gt; str:
    &#34;&#34;&#34;
    Copies the current file or directory to a new destination within the Quetzal file system, updating metadata
    accordingly.

    This method copies the file/directory represented by this instance to the specified destination directory,
    also handling metadata and description files to reflect the new location.

    Args:
        dest_dir (QueztalFile): The destination `QuetzalFile` directory where this file/directory is to be copied.

    Returns:
        A string message indicating the successful copy operation.
    &#34;&#34;&#34;
    debug(f&#34;{self.name} called on copy to &#34;, dest_dir)
    assert dest_dir._type == FileType.DIRECTORY

    # Adjust Destination relative Path
    destination_path = dest_dir._abs_path
    dest_dir: Path = destination_path.relative_to(self._root_dir.absolute())

    # Rename destination if it is duplicates
    dest = getCopyName(self._root_dir / dest_dir / self._path.name)
    
    # Copy target File
    source = self._root_dir / self._path
    if self._type == FileType.DIRECTORY:
        shutil.copytree(source, dest)
    else:
        shutil.copy2(source, dest)
    
    # Update metaData
    self._updateMetaForCopy(dest.relative_to(self._root_dir))
    
    return f&#39;&#34;{self.name}&#34; copied to &#34;{dest_dir}&#34;&#39;</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile._delete"><code class="name flex">
<span>def <span class="ident">_delete</span></span>(<span>self) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes the current file or directory and cleans up its associated metadata
and description files.</p>
<h2 id="returns">Returns</h2>
<p>A confirmation message indicating the successful deletion.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _delete(self) -&gt; str:
    &#34;&#34;&#34;
    Deletes the current file or directory and cleans up its associated metadata
    and description files.

    Returns:
        A confirmation message indicating the successful deletion.
    &#34;&#34;&#34;
    assert (
        self._mode == AccessMode.OWNER or self._permission == Permission.FULL_WRITE
    )

    debug(f&#34;\n\n\t{self.name} called on delete\n&#34;)

    if self._type == FileType.FILE:
        os.remove(self._root_dir / self._path)
    else:  # For directories
        shutil.rmtree(self._root_dir / self._path)

    self._updateMetaForDelete()

    return f&#39;&#34;{self.name}&#34; Deleted&#39;</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile._editDescription"><code class="name flex">
<span>def <span class="ident">_editDescription</span></span>(<span>self, value:str) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the description for the file or directory with the given value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code></dt>
<dd>The new description to be applied to the file or directory.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A confirmation message indicating the successful update of the description.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _editDescription(self, value: str) -&gt; str:
    &#34;&#34;&#34;
    Updates the description for the file or directory with the given value.

    Args:
        value (str): The new description to be applied to the file or directory.

    Returns:
        A confirmation message indicating the successful update of the description.
    &#34;&#34;&#34;
    assert (
        self._mode == AccessMode.OWNER or self._permission == Permission.FULL_WRITE
    )

    debug(f&#34;\n\t{self.name} called on editMetaData {value}\n&#34;)
    description_file_path = self.getDescriptionPath(self._path)

    # Overwrite the existing description with the new value
    with open(description_file_path, &#34;w&#34;) as file:
        file.write(value)

    return f&#39;&#34;{self.name}&#34; Edit Success&#39;</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile._makeDefaultDescription"><code class="name flex">
<span>def <span class="ident">_makeDefaultDescription</span></span>(<span>self, path:Union[str,pathlib.Path])</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a default description file for a file or directory if one does not already exist.</p>
<p>This method is typically called when a new file or directory is added to ensure that it has a basic description.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>The path to the file or directory for which a default description is to be created.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _makeDefaultDescription(self, path: Union[str, Path]):
    &#34;&#34;&#34;
    Creates a default description file for a file or directory if one does not already exist.

    This method is typically called when a new file or directory is added to ensure that it has a basic description.

    Args:
        path: The path to the file or directory for which a default description is to be created.
    &#34;&#34;&#34;
    if self._type == FileType.DIRECTORY:
        default_content = self.PROJECT_DEFAULT_DESCRIPTION
    else:
        default_content = self.FILE_DEFAULT_DESCRIPTION

    with open(path, &#34;w&#34;) as file:
        file.write(default_content)</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile._move"><code class="name flex">
<span>def <span class="ident">_move</span></span>(<span>self, dest_dir:<a title="quetzal.dtos.dtos.QuetzalFile" href="#quetzal.dtos.dtos.QuetzalFile">QuetzalFile</a>) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Moves the current file or directory to a new destination within the Quetzal file system, updating metadata
accordingly.</p>
<p>This method moves the file/directory represented by this instance to the specified destination directory,
handling metadata and description files to reflect the new location. It also ensures that the move does not
violate any system rules, such as moving into a subdirectory of itself.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dest_dir</code></strong> :&ensp;<code><a title="quetzal.dtos.dtos.QuetzalFile" href="#quetzal.dtos.dtos.QuetzalFile">QuetzalFile</a></code></dt>
<dd>The destination <code><a title="quetzal.dtos.dtos.QuetzalFile" href="#quetzal.dtos.dtos.QuetzalFile">QuetzalFile</a></code> directory where this file/directory is to be moved.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A string message indicating the successful move operation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _move(self, dest_dir: &#34;QuetzalFile&#34;) -&gt; str:
    &#34;&#34;&#34;
    Moves the current file or directory to a new destination within the Quetzal file system, updating metadata
    accordingly.

    This method moves the file/directory represented by this instance to the specified destination directory,
    handling metadata and description files to reflect the new location. It also ensures that the move does not
    violate any system rules, such as moving into a subdirectory of itself.

    Args:
        dest_dir (QuetzalFile): The destination `QuetzalFile` directory where this file/directory is to be moved.

    Returns:
        A string message indicating the successful move operation.
    &#34;&#34;&#34;
    assert (
        self._mode == AccessMode.OWNER or self._permission == Permission.FULL_WRITE
    )
    debug(f&#34;{self.name} called on move to &#34;, dest_dir)

     # Adjust Destination relative Path
    destination_path = dest_dir._abs_path
    dest_dir: Path = destination_path.relative_to(self._root_dir.absolute())

    # Varify destination is valid
    source = self._root_dir / self._path
    dest = self._root_dir / dest_dir

    if (dest / self._path.name).exists():
        raise FileExistsError(
            f&#39;File/directory with name &#34;{self._path.name}&#34; already exist at the destination.&#39;
        )

    if dest.is_relative_to(source):
        raise Exception(f&#34;You can&#39;t move a directory into itself.&#34;)

    # Move file, metadata, and description
    if self._type == FileType.DIRECTORY:
        shutil.move(source, dest)
    else:
        dest = dest / self._path.name
        shutil.move(source, dest)
    
    # Update metaData
    self._updateMetaForMove(dest_dir)
    
    return f&#39;&#34;{self.name}&#34; moved to &#34;{dest_dir}&#34;&#39;</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile._newDirectory"><code class="name flex">
<span>def <span class="ident">_newDirectory</span></span>(<span>self, dir_name:Union[str,pathlib.Path]) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new directory under the current QuetzalFile path and updates the metadata and
description for it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dir_name</code></strong> :&ensp;<code>Union[str, Path]</code></dt>
<dd>The name of the new directory to create.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A confirmation message indicating the successful creation of the directory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _newDirectory(self, dir_name: Union[str, Path]) -&gt; str:
    &#34;&#34;&#34;
    Creates a new directory under the current QuetzalFile path and updates the metadata and
    description for it.

    Args:
        dir_name (Union[str, Path]): The name of the new directory to create.

    Returns:
        A confirmation message indicating the successful creation of the directory.
    &#34;&#34;&#34;
    dir_name = Path(dir_name)
    assert (
        self._mode == AccessMode.OWNER or self._permission != Permission.READ_ONLY
    )
    assert self._type == FileType.DIRECTORY
    assert dir_name.stem not in reserved_names

    debug(f&#34;\n\n\t{self.name} called on New dir {dir_name}\n&#34;)
    
    new_dir_path = self._root_dir / self._path / dir_name
    if new_dir_path.exists():
        raise FileExistsError(
            f&#39;Directory with name &#34;{dir_name}&#34; already exist at the destination.&#39;
        )
    os.makedirs(new_dir_path, exist_ok=False)

    self._updateMetaForNewFile(
        self._path,
        dir_name,
        self.PROJECT_DEFAULT_META + &#34;CreatedBy::= &#34; + self._user.id + &#34;\n&#34;,
        self.PROJECT_DEFAULT_DESCRIPTION,
        isDir=True
    )

    return f&#39;&#34;{dir_name}&#34; Created&#39;</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile._parseMetadata"><code class="name flex">
<span>def <span class="ident">_parseMetadata</span></span>(<span>self, metadata:Optional[dict[str,typing.Union[<a title="quetzal.dtos.dtos.Permission" href="#quetzal.dtos.dtos.Permission">Permission</a>,<a title="quetzal.dtos.dtos.Visibility" href="#quetzal.dtos.dtos.Visibility">Visibility</a>,<a title="quetzal.dtos.dtos.FileType" href="#quetzal.dtos.dtos.FileType">FileType</a>,<a title="quetzal.dtos.dtos.AnalysisProgress" href="#quetzal.dtos.dtos.AnalysisProgress">AnalysisProgress</a>,quetzal.dtos.dtos.CreatedBy,quetzal.dtos.dtos.SpecificType]]])</span>
</code></dt>
<dd>
<div class="desc"><p>Assign Queztalfile metadata into attribute variables</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>metadata</code></strong> :&ensp;<code>Optional[dict[str, MetaData]]</code></dt>
<dd>metadata</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _parseMetadata(self, metadata: Optional[dict[str, MetaData]]):
    &#34;&#34;&#34;
    Assign Queztalfile metadata into attribute variables
    
    Args:
        metadata (Optional[dict[str, MetaData]]): metadata
    &#34;&#34;&#34;
    if metadata is None:
        metadata = self.loadMetaData(self._path)

    self._created_by = metadata[&#34;CreatedBy&#34;]
    self._type = metadata[&#34;FileType&#34;]
    self._visibility = metadata[&#34;Visibility&#34;]
    self._analysis_progress = metadata[&#34;AnalysisProgress&#34;]
    self._permission = metadata[&#34;Permission&#34;]</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile._rename"><code class="name flex">
<span>def <span class="ident">_rename</span></span>(<span>self, new_file_name:Union[str,pathlib.Path]) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Renames the current QuetzalFile (file or directory) to the new specified name and updates
the metadata accordingly.</p>
<p>For given new_file_name, only the name of the file will be considered. Parent_name, and suffix of the name
will be modified to match the original file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>new_file_name</code></strong> :&ensp;<code>Union[str, Path]</code></dt>
<dd>The new name for the file or directory.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A confirmation message indicating the successful rename.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _rename(self, new_file_name: Union[str, Path]) -&gt; str:
    &#34;&#34;&#34;
    Renames the current QuetzalFile (file or directory) to the new specified name and updates
    the metadata accordingly.
    
    For given new_file_name, only the name of the file will be considered. Parent_name, and suffix of the name
    will be modified to match the original file.

    Args:
        new_file_name (Union[str, Path]): The new name for the file or directory.

    Returns:
        A confirmation message indicating the successful rename.
    &#34;&#34;&#34;
    
    new_file_name = Path(new_file_name)
    assert (
        self._mode == AccessMode.OWNER or self._permission == Permission.FULL_WRITE
    )
    assert new_file_name.stem not in reserved_names

    debug(f&#34;\n\n\t{self.name} called on rename {new_file_name}\n&#34;)

    # Validate suffix
    if new_file_name.suffix != self._path.suffix:
        new_file_name = Path(new_file_name.name + self._path.suffix)

    # Rename
    new_path = self._path.parent / new_file_name
    new_path_abs = self._root_dir / new_path
    if new_path_abs.exists():
        raise FileExistsError(
            f&#39;File/directory with name &#34;{new_file_name}&#34; already exist at the destination.&#39;
        )
    os.rename(self._abs_path, new_path_abs)
    self._updateMetaForRename(new_path=new_path)

    org_name = self.name
    self._path = new_path
    return f&#39;&#34;{org_name}&#34; renamed to &#34;{self.name}&#34;&#39;</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile._share"><code class="name flex">
<span>def <span class="ident">_share</span></span>(<span>self, shared:<a title="quetzal.dtos.dtos.Visibility" href="#quetzal.dtos.dtos.Visibility">Visibility</a>, permission:<a title="quetzal.dtos.dtos.Permission" href="#quetzal.dtos.dtos.Permission">Permission</a>) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Applies new sharing settings to the file or directory, affecting its visibility
and access permissions, and updates the metadata accordingly.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shared</code></strong> :&ensp;<code><a title="quetzal.dtos.dtos.Visibility" href="#quetzal.dtos.dtos.Visibility">Visibility</a></code></dt>
<dd>The new visibility setting.</dd>
<dt><strong><code>permission</code></strong> :&ensp;<code><a title="quetzal.dtos.dtos.Permission" href="#quetzal.dtos.dtos.Permission">Permission</a></code></dt>
<dd>The new access permission setting.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A confirmation message indicating the updated sharing settings.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _share(self, shared: Visibility, permission: Permission) -&gt; str:
    &#34;&#34;&#34;
    Applies new sharing settings to the file or directory, affecting its visibility
    and access permissions, and updates the metadata accordingly.

    Args:
        shared (Visibility): The new visibility setting.
        permission (Permission): The new access permission setting.

    Returns:
        A confirmation message indicating the updated sharing settings.
    &#34;&#34;&#34;
    assert (
        self._mode == AccessMode.OWNER or self._permission == Permission.FULL_WRITE
    )

    if shared == self._visibility and permission == self._permission:
        return None

    debug(f&#34;\n\n\t{self.name} called on share {shared}:{permission}\n&#34;)

    self._updateMetaForShare(shared, permission)

    # If the QuetzalFile is a directory, apply the changes to all sub-projects and video files
    if self._type == FileType.DIRECTORY:
        for subfile in self.iterdir():
            subfile._updateMetaForShare(shared, permission)

    return f&#39;&#34;{self.name}&#34; Sharing Setting Updated&#39;</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile._syncAnalysisState"><code class="name flex">
<span>def <span class="ident">_syncAnalysisState</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Synchronizes the analysis state of the file with the current status in the
analysis engine or database, updating the metadata as necessary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _syncAnalysisState(self):
    &#34;&#34;&#34;
    Synchronizes the analysis state of the file with the current status in the
    analysis engine or database, updating the metadata as necessary.
    &#34;&#34;&#34;
    assert self._type == FileType.FILE
    
    return</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile._updateMetaForAnalyze"><code class="name flex">
<span>def <span class="ident">_updateMetaForAnalyze</span></span>(<span>self, new_progress:<a title="quetzal.dtos.dtos.AnalysisProgress" href="#quetzal.dtos.dtos.AnalysisProgress">AnalysisProgress</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the metadata for the file to reflect a new state of analysis progress.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>new_progress</code></strong> :&ensp;<code><a title="quetzal.dtos.dtos.AnalysisProgress" href="#quetzal.dtos.dtos.AnalysisProgress">AnalysisProgress</a></code></dt>
<dd>The new analysis progress state to update the metadata with.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _updateMetaForAnalyze(self, new_progress: AnalysisProgress):
    &#34;&#34;&#34;
    Updates the metadata for the file to reflect a new state of analysis progress.

    Args:
        new_progress (AnalysisProgress): The new analysis progress state to update the metadata with.
    &#34;&#34;&#34;
    
    orig_path_full = self._metadata_dir / self._path
    metadata_path = self._getMetaDataPath(orig_path_full)

    if os.path.exists(metadata_path):
        with open(metadata_path, &#34;r+&#34;) as file:
            metadata = file.read()
            metadata = metadata.replace(
                f&#34;AnalysisProgress::= {self._analysis_progress.value}&#34;,
                f&#34;AnalysisProgress::= {new_progress.value}&#34;,
            )
            file.seek(0)
            file.write(metadata)
            file.truncate()</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile._updateMetaForCopy"><code class="name flex">
<span>def <span class="ident">_updateMetaForCopy</span></span>(<span>self, dest:pathlib.Path)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the metadata for a file or directory when it is copied to a new location.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dest</code></strong></dt>
<dd>The destination path where the file or directory has been copied.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _updateMetaForCopy(self, dest: Path):
    &#34;&#34;&#34;
    Updates the metadata for a file or directory when it is copied to a new location.

    Args:
        dest: The destination path where the file or directory has been copied.
    &#34;&#34;&#34;
    source_metadata = self._metadata_dir / self._path
    dest_metadata = self._metadata_dir / dest
    
    if self._type == FileType.DIRECTORY:
        shutil.copytree(source_metadata, dest_metadata)
    
    source_metadata_path = self._getMetaDataPath(source_metadata)
    dest_metadata_path = self._getMetaDataPath(dest_metadata)
    shutil.copy2(source_metadata_path, dest_metadata_path)

    source_desc_path = self._getDescriptionPath(source_metadata)
    dest_desc_path = self._getDescriptionPath(dest_metadata)
    shutil.copy2(source_desc_path, dest_desc_path)</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile._updateMetaForDelete"><code class="name flex">
<span>def <span class="ident">_updateMetaForDelete</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Cleans up the metadata and description files associated with the file or directory
that is being deleted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _updateMetaForDelete(self):
    &#34;&#34;&#34;
    Cleans up the metadata and description files associated with the file or directory
    that is being deleted.
    &#34;&#34;&#34;
    orig_path_full = self._metadata_dir / self._path
    metadata_path = self._getMetaDataPath(orig_path_full)
    description_path = self._getDescriptionPath(orig_path_full)

    if metadata_path.exists():
        os.remove(metadata_path)
    if description_path.exists():
        os.remove(description_path)
    if orig_path_full.exists():
        shutil.rmtree(orig_path_full)</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile._updateMetaForMove"><code class="name flex">
<span>def <span class="ident">_updateMetaForMove</span></span>(<span>self, dest_dir:pathlib.Path)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the metadata for a file or directory when it is moved to a new location.</p>
<p>This includes moving the metadata and description files to reflect the new file path and updating any
directory-specific metadata if the moved entity is a directory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dest_dir</code></strong> :&ensp;<code>Path</code></dt>
<dd>The destination path where the file or directory has been moved.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _updateMetaForMove(self, dest_dir: Path):
    &#34;&#34;&#34;
    Updates the metadata for a file or directory when it is moved to a new location.

    This includes moving the metadata and description files to reflect the new file path and updating any
    directory-specific metadata if the moved entity is a directory.

    Args:
        dest_dir (Path): The destination path where the file or directory has been moved.
    &#34;&#34;&#34;
    source_metadata = self._metadata_dir / self._path
    
    if self._type == FileType.DIRECTORY:
        dest_metadata = self._metadata_dir / dest_dir
        shutil.move(source_metadata, dest_metadata)
    else:
        dest_metadata = self._metadata_dir / dest_dir / self._path.name

    source_metadata_path = self._getMetaDataPath(source_metadata)
    dest_metadata_path = self._getMetaDataPath(dest_metadata)
    shutil.move(source_metadata_path, dest_metadata_path)

    source_desc_path = self._getDescriptionPath(source_metadata)
    dest_desc_path = self._getDescriptionPath(dest_metadata)
    shutil.move(source_desc_path, dest_desc_path)</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile._updateMetaForNewFile"><code class="name flex">
<span>def <span class="ident">_updateMetaForNewFile</span></span>(<span>self, target_path:pathlib.Path, file_name:pathlib.Path, meta_data:str, description:str, isDir:bool=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and updates the metadata and description for a new file or directory
that is being added to the filesystem.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target_path</code></strong> :&ensp;<code>Path</code></dt>
<dd>The target path where the new file or directory is located.</dd>
<dt><strong><code>file_name</code></strong> :&ensp;<code>Path</code></dt>
<dd>The name of the new file or directory.</dd>
<dt><strong><code>meta_data</code></strong> :&ensp;<code>str</code></dt>
<dd>The metadata to be written for the new file or directory.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code></dt>
<dd>The description to be written for the new file or directory.</dd>
<dt><strong><code>isDir</code></strong> :&ensp;<code>bool</code></dt>
<dd>A flag indicating whether the new entity is a directory. Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _updateMetaForNewFile(
    self, target_path: Path, file_name: Path, meta_data: str, description: str, isDir: bool=False
):
    &#34;&#34;&#34;
    Creates and updates the metadata and description for a new file or directory
    that is being added to the filesystem.

    Args:
        target_path (Path): The target path where the new file or directory is located.
        file_name (Path): The name of the new file or directory.
        meta_data (str): The metadata to be written for the new file or directory.
        description (str): The description to be written for the new file or directory.
        isDir (bool): A flag indicating whether the new entity is a directory. Defaults to False.
    &#34;&#34;&#34;
    # Crate New Meta Data, Description, and Directory
    new_file_metadata = self._metadata_dir / target_path / file_name
    if isDir:
        os.makedirs(new_file_metadata, exist_ok=True)

    new_file_metadata_path = self._getMetaDataPath(new_file_metadata)
    with open(new_file_metadata_path, &#34;w&#34;) as file:
        file.write(meta_data)

    new_file_description_path = self._getDescriptionPath(new_file_metadata)
    with open(new_file_description_path, &#34;w&#34;) as file:
        file.write(description)</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile._updateMetaForRename"><code class="name flex">
<span>def <span class="ident">_updateMetaForRename</span></span>(<span>self, new_path:Union[str,pathlib.Path])</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the metadata and description files' paths for the current QuetzalFile
instance to reflect a change in the file or directory's name (rename action).</p>
<p>This method is invoked internally to handle the renaming of metadata and description
files associated with the QuetzalFile, ensuring consistency within the filesystem.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>new_path</code></strong> :&ensp;<code>Union[str, Path]</code></dt>
<dd>The new path (name) for the file or directory, reflecting the rename.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _updateMetaForRename(self, new_path: Union[str, Path]):
    &#34;&#34;&#34;
    Updates the metadata and description files&#39; paths for the current QuetzalFile
    instance to reflect a change in the file or directory&#39;s name (rename action).

    This method is invoked internally to handle the renaming of metadata and description
    files associated with the QuetzalFile, ensuring consistency within the filesystem.

    Args:
        new_path (Union[str, Path]): The new path (name) for the file or directory, reflecting the rename.
    &#34;&#34;&#34;
    orig_path_full = self._metadata_dir / self._path
    new_path_full = self._metadata_dir / new_path
    
    ## New Directory if needed
    if self._type == FileType.DIRECTORY:
        if orig_path_full.exists():
            os.rename(orig_path_full, new_path_full)
        
    ## Rename Metadata
    metadata_path = self._getMetaDataPath(orig_path_full)
    new_metadata_path = self._getMetaDataPath(new_path_full)
    if metadata_path.exists():
        os.rename(metadata_path, new_metadata_path)
    else:
        with open(new_metadata_path, &#34;w&#34;) as file:
            file.write(
                self.PROJECT_DEFAULT_META
                if self._type == FileType.DIRECTORY
                else self.FILE_DEFAULT_META
            )

    ## Rename Description
    description_path = self._getDescriptionPath(orig_path_full)
    new_description_path = self._getDescriptionPath(new_path_full)
    if description_path.exists():
        os.rename(description_path, new_description_path)
    else:
        with open(new_description_path, &#34;w&#34;) as file:
            file.write(
                self.PROJECT_DEFAULT_DESCRIPTION
                if self._type == FileType.DIRECTORY
                else self.FILE_DEFAULT_DESCRIPTION
            )</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile._updateMetaForShare"><code class="name flex">
<span>def <span class="ident">_updateMetaForShare</span></span>(<span>self, shared:<a title="quetzal.dtos.dtos.Visibility" href="#quetzal.dtos.dtos.Visibility">Visibility</a>, permission:<a title="quetzal.dtos.dtos.Permission" href="#quetzal.dtos.dtos.Permission">Permission</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the metadata for the QuetzalFile (file or directory) to reflect new sharing settings,
including visibility and permissions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shared</code></strong> :&ensp;<code><a title="quetzal.dtos.dtos.Visibility" href="#quetzal.dtos.dtos.Visibility">Visibility</a></code></dt>
<dd>The new visibility setting for the file or directory.</dd>
<dt><strong><code>permission</code></strong> :&ensp;<code><a title="quetzal.dtos.dtos.Permission" href="#quetzal.dtos.dtos.Permission">Permission</a></code></dt>
<dd>The new permission setting for the file or directory.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _updateMetaForShare(self, shared: Visibility, permission: Permission):
    &#34;&#34;&#34;
    Updates the metadata for the QuetzalFile (file or directory) to reflect new sharing settings,
    including visibility and permissions.

    Args:
        shared (Visibility): The new visibility setting for the file or directory.
        permission (Permission): The new permission setting for the file or directory.
    &#34;&#34;&#34;
    metadata_path = self.getMetaDataPath(self._path)
    if os.path.exists(metadata_path):
        with open(metadata_path, &#34;r+&#34;) as file:
            metadata = file.read()
            metadata = metadata.replace(
                f&#34;Visibility::= {self._visibility.value}&#34;,
                f&#34;Visibility::= {shared.value}&#34;,
            )
            metadata = metadata.replace(
                f&#34;Permission::= {self._permission.value}&#34;,
                f&#34;Permission::= {permission.value}&#34;,
            )
            file.seek(0)
            file.write(metadata)
            file.truncate()

    self._visibility = shared
    self._permission = permission</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile._upload"><code class="name flex">
<span>def <span class="ident">_upload</span></span>(<span>self, uploaded_files:Union[str,pathlib.Path]) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Uploads and saves the specified files to the current QuetzalFile directory, updating
the metadata for each uploaded file.</p>
<p>The method should fail when called on QuetzalFile with "File" filetype.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>uploaded_files</code></strong> :&ensp;<code>Union[str, Path]</code></dt>
<dd>The files to be uploaded.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A confirmation message indicating the number of files successfully uploaded.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _upload(self, uploaded_files: Union[str, Path]) -&gt; str:
    &#34;&#34;&#34;
    Uploads and saves the specified files to the current QuetzalFile directory, updating
    the metadata for each uploaded file.
    
    The method should fail when called on QuetzalFile with &#34;File&#34; filetype.

    Args:
        uploaded_files (Union[str, Path]): The files to be uploaded.

    Returns:
        A confirmation message indicating the number of files successfully uploaded.
    &#34;&#34;&#34;
    assert self._mode == AccessMode.OWNER or self._permission != Permission.READ_ONLY
    assert self._type == FileType.DIRECTORY
    
    for uploaded_file in uploaded_files:
        assert Path(uploaded_file.name).stem not in reserved_names
        debug(f&#34;\n\n\t{self.name} called on upload {uploaded_file.name}\n&#34;)

        dest: Path = self._root_dir / self._path / uploaded_file.name
        orig_name = dest
        start_num = 0
        while dest.exists():
            dest = appendText(orig_name, f&#34;_{start_num}&#34;)
            start_num += 1

        with open(dest, mode=&#34;wb&#34;) as w:
            w.write(uploaded_file.getvalue())

        self._updateMetaForNewFile(
            self._path,
            dest.name,
            self.FILE_DEFAULT_META + &#34;CreatedBy::= &#34; + self._user.id + &#34;\n&#34;,
            self.FILE_DEFAULT_DESCRIPTION,
        )

    return f&#34;{len(uploaded_files)} files successfully uploaded&#34;</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile.getDescription"><code class="name flex">
<span>def <span class="ident">getDescription</span></span>(<span>self) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the description of the current file or directory.</p>
<p>If a description file does not exist, a default description is created and then retrieved.</p>
<h2 id="returns">Returns</h2>
<p>The description text of the file or directory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getDescription(self) -&gt; str:
    &#34;&#34;&#34;
    Retrieves the description of the current file or directory.

    If a description file does not exist, a default description is created and then retrieved.

    Returns:
        The description text of the file or directory.
    &#34;&#34;&#34;
    description_file_path = self.getDescriptionPath(self._path)

    # if not os.path.exists(description_file_path):
    if not description_file_path.exists():
        self._makeDefaultDescription(description_file_path)

    with open(description_file_path, &#34;r&#34;) as file:
        return file.read()</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile.getDescriptionPath"><code class="name flex">
<span>def <span class="ident">getDescriptionPath</span></span>(<span>self, path:pathlib.Path)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the full path to the description file associated with a given file or directory path,
based on current QuetzalFile configuration.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>Path</code></dt>
<dd>The path to the file or directory whose description file path is to be retrieved.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The full <code>Path</code> object pointing to the description file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getDescriptionPath(self, path: Path):
    &#34;&#34;&#34;
    Retrieves the full path to the description file associated with a given file or directory path, 
    based on current QuetzalFile configuration.

    Args:
        path (Path): The path to the file or directory whose description file path is to be retrieved.

    Returns:
        The full `Path` object pointing to the description file.
    &#34;&#34;&#34;
    return self._getDescriptionPath(self._metadata_dir / path)</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile.getMetaDataPath"><code class="name flex">
<span>def <span class="ident">getMetaDataPath</span></span>(<span>self, path:pathlib.Path) >pathlib.Path</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the full path to the metadata file associated with a given file or directory path,
based on current QuetzalFile configuration.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>Path</code></dt>
<dd>The path to the file or directory whose metadata file path is to be retrieved.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The full <code>Path</code> object pointing to the metadata file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getMetaDataPath(self, path: Path) -&gt; Path:
    &#34;&#34;&#34;
    Retrieves the full path to the metadata file associated with a given file or directory path, 
    based on current QuetzalFile configuration.

    Args:
        path (Path): The path to the file or directory whose metadata file path is to be retrieved.

    Returns:
        The full `Path` object pointing to the metadata file.
    &#34;&#34;&#34;
    return self._getMetaDataPath(self._metadata_dir / path)</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile.iterdir"><code class="name flex">
<span>def <span class="ident">iterdir</span></span>(<span>self, sharedOnly=False, directoryOnly=False) >list[<a title="quetzal.dtos.dtos.QuetzalFile" href="#quetzal.dtos.dtos.QuetzalFile">QuetzalFile</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Lists the contents of the directory represented by this QuetzalFile.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sharedOnly</code></strong></dt>
<dd>If True, only shared files/directories are listed.</dd>
<dt><strong><code>directoryOnly</code></strong></dt>
<dd>If True, only directories are listed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of QuetzalFile objects representing the contents of the directory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iterdir(
    self,
    sharedOnly=False,
    directoryOnly=False,
) -&gt; list[&#34;QuetzalFile&#34;]:
    &#34;&#34;&#34;
    Lists the contents of the directory represented by this QuetzalFile.

    Args:
        sharedOnly: If True, only shared files/directories are listed.
        directoryOnly: If True, only directories are listed.

    Returns:
        A list of QuetzalFile objects representing the contents of the directory.
    &#34;&#34;&#34;
    
    assert self._type == FileType.DIRECTORY
    
    if self._iterdir:
        return self._iterdir

    directories = []
    files = []
    directory_path = self._root_dir / self._path

    sorted_items = sorted(directory_path.iterdir(), key=lambda x: x.stem.lower())
    for item in sorted_items:
        # Load MetaData of the file
        try:
            metadata = self.loadMetaData(item.relative_to(self._root_dir))
        except:
            continue

        # Filter Only Directory
        isdir = metadata[&#34;FileType&#34;] == FileType.DIRECTORY
        if directoryOnly and not isdir:
            continue

        # Filter only shared
        if sharedOnly and metadata[&#34;Visibility&#34;] != Visibility.SHARED:
            continue
        
        file = QuetzalFile._instantiateFile(
            path=item.relative_to(self._root_dir),
            root_dir=self._root_dir,
            metadata_dir=self._metadata_dir,
            user=self._user,
            home=self._home,
            metadata=metadata,
            parent=self,
        )

        # Sort to have directory first
        if isdir:
            directories.append(file)
        else:
            files.append(file)

    self._iterdir = directories + files
    return self._iterdir</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile.loadMetaData"><code class="name flex">
<span>def <span class="ident">loadMetaData</span></span>(<span>self, file:Union[str,pathlib.Path]) >dict[str,typing.Union[<a title="quetzal.dtos.dtos.Permission" href="#quetzal.dtos.dtos.Permission">Permission</a>,<a title="quetzal.dtos.dtos.Visibility" href="#quetzal.dtos.dtos.Visibility">Visibility</a>,<a title="quetzal.dtos.dtos.FileType" href="#quetzal.dtos.dtos.FileType">FileType</a>,<a title="quetzal.dtos.dtos.AnalysisProgress" href="#quetzal.dtos.dtos.AnalysisProgress">AnalysisProgress</a>,quetzal.dtos.dtos.CreatedBy,quetzal.dtos.dtos.SpecificType]]</span>
</code></dt>
<dd>
<div class="desc"><p>Loads and returns the metadata for the specified file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadMetaData(self, file: Union[str, Path]) -&gt; dict[str, MetaData]:
    &#34;&#34;&#34;
    Loads and returns the metadata for the specified file.
    &#34;&#34;&#34;
    metadata_path = self.getMetaDataPath(file)
    return self._loadMetaData(metadata_path)</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.QuetzalFile.perform"><code class="name flex">
<span>def <span class="ident">perform</span></span>(<span>self, action:<a title="quetzal.dtos.dtos.Action" href="#quetzal.dtos.dtos.Action">Action</a>, input:dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs the specified "Action" on this QuetzalFile object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>action</code></strong></dt>
<dd>The action to perform, as defined by the Action enum.</dd>
<dt><strong><code>input</code></strong></dt>
<dd>A dictionary containing the input parameters required for the action.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A string message indicating the outcome of the action, or None if no action was performed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def perform(self, action: Action, input: dict):
    &#34;&#34;&#34;
    Performs the specified &#34;Action&#34; on this QuetzalFile object.

    Args:
        action: The action to perform, as defined by the Action enum.
        input: A dictionary containing the input parameters required for the action.

    Returns:
        A string message indicating the outcome of the action, or None if no action was performed.
    &#34;&#34;&#34;
    
    self._iterdir = None
    if self._parent:
        self._parent._iterdir = None
    match action:
        case Action.NEW_DIR:
            return self._newDirectory(**input)
        case Action.UPLOAD_FILE:
            return self._upload(**input)
        case Action.RENAME:
            return self._rename(**input)
        case Action.SHARE:
            return self._share(**input)
        case Action.DELETE:
            return self._delete(**input)
        case Action.ANALYZE:
            return self._analyze(**input)
        case Action.EDIT:
            return self._editDescription(**input)
        case Action.COPY:
            return self._copy(**input)
        case Action.MOVE:
            return self._move(**input)
        case _:
            raise NotImplemented(&#34;No Action Implemneted&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="quetzal.dtos.dtos.User"><code class="flex name class">
<span>class <span class="ident">User</span></span>
</code></dt>
<dd>
<div class="desc"><p>Represents a user, identified by a unique identifier.</p>
<p>Initializes a User instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>Optional[UserId]</code></dt>
<dd>The unique identifier for the user. Defaults to None, representing a guest.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class User:
    &#34;&#34;&#34;Represents a user, identified by a unique identifier.&#34;&#34;&#34;
    GuestId = None

    def __init__(self, id: Union[UserId, &#34;User&#34;] = None):
        &#34;&#34;&#34;Initializes a User instance.
        
        Args:
            id (Optional[UserId]): The unique identifier for the user. Defaults to None, representing a guest.
        &#34;&#34;&#34;
        match id:
            case User() as user:
                self._id = user._id
            case _:
                self._id = id if id else User.GuestId

    @property
    def id(self) -&gt; UserId:
        &#34;&#34;&#34;Gets the user&#39;s unique identifier.&#34;&#34;&#34;
        return self._id

    @id.setter
    def id(self, value):
        &#34;&#34;&#34;Sets the user&#39;s unique identifier.&#34;&#34;&#34;
        self._id = value

    def __eq__(self, other):
        &#34;&#34;&#34;Checks equality with another User instance or a string id.&#34;&#34;&#34;
        match other:
            case User():
                return self._id == other._id
            case str():
                return self._id == other
            case _:
                return NotImplemented

    def __repr__(self):
        &#34;&#34;&#34;Represents the User instance as a string.&#34;&#34;&#34;
        match self._id:
            case User.GuestId:
                return &#34;Guest&#34;
            case _:
                return f&#34;&lt;User: {str(self._id)}&gt;&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="quetzal.dtos.dtos.User.GuestId"><code class="name">var <span class="ident">GuestId</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.User.__hash__"><code class="name">var <span class="ident">__hash__</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="quetzal.dtos.dtos.User.id"><code class="name">var <span class="ident">id</span> :quetzal.dtos.dtos.UserId</code></dt>
<dd>
<div class="desc"><p>Gets the user's unique identifier.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def id(self) -&gt; UserId:
    &#34;&#34;&#34;Gets the user&#39;s unique identifier.&#34;&#34;&#34;
    return self._id</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="quetzal.dtos.dtos.User.__eq__"><code class="name flex">
<span>def <span class="ident">__eq__</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks equality with another User instance or a string id.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __eq__(self, other):
    &#34;&#34;&#34;Checks equality with another User instance or a string id.&#34;&#34;&#34;
    match other:
        case User():
            return self._id == other._id
        case str():
            return self._id == other
        case _:
            return NotImplemented</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.User.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, id:Union[quetzal.dtos.dtos.UserId,ForwardRef('<a title="quetzal.dtos.dtos.User" href="#quetzal.dtos.dtos.User">User</a>')]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a User instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>Optional[UserId]</code></dt>
<dd>The unique identifier for the user. Defaults to None, representing a guest.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __init__(self, id: Union[UserId, &#34;User&#34;] = None):
    &#34;&#34;&#34;Initializes a User instance.
    
    Args:
        id (Optional[UserId]): The unique identifier for the user. Defaults to None, representing a guest.
    &#34;&#34;&#34;
    match id:
        case User() as user:
            self._id = user._id
        case _:
            self._id = id if id else User.GuestId</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.User.__repr__"><code class="name flex">
<span>def <span class="ident">__repr__</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the User instance as a string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __repr__(self):
    &#34;&#34;&#34;Represents the User instance as a string.&#34;&#34;&#34;
    match self._id:
        case User.GuestId:
            return &#34;Guest&#34;
        case _:
            return f&#34;&lt;User: {str(self._id)}&gt;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="quetzal.dtos.dtos.Visibility"><code class="flex name class">
<span>class <span class="ident">Visibility</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines visibility settings for files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Visibility(Enum):
    &#34;&#34;&#34;Defines visibility settings for files.&#34;&#34;&#34;
    SHARED = &#34;shared&#34;
    PRIVATE = &#34;private&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="quetzal.dtos.dtos.Visibility.PRIVATE"><code class="name">var <span class="ident">PRIVATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.Visibility.SHARED"><code class="name">var <span class="ident">SHARED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.Visibility._member_map_"><code class="name">var <span class="ident">_member_map_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.Visibility._member_names_"><code class="name">var <span class="ident">_member_names_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.Visibility._member_type_"><code class="name">var <span class="ident">_member_type_</span></code></dt>
<dd>
<div class="desc"><p>The base class of the class hierarchy.</p>
<p>When called, it accepts no arguments and returns a new featureless
instance that has no instance attributes and cannot be given any.</p></div>
</dd>
<dt id="quetzal.dtos.dtos.Visibility._unhashable_values_"><code class="name">var <span class="ident">_unhashable_values_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.Visibility._use_args_"><code class="name">var <span class="ident">_use_args_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.Visibility._value2member_map_"><code class="name">var <span class="ident">_value2member_map_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.dtos.Visibility._value_repr_"><code class="name">var <span class="ident">_value_repr_</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="quetzal.dtos.dtos.Visibility.__new__"><code class="name flex">
<span>def <span class="ident">__new__</span></span>(<span>cls, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Create and return a new object.
See help(type) for accurate signature.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __new__(cls, value):
    # all enum instances are actually created during class construction
    # without calling this method; this method is called by the metaclass&#39;
    # __call__ (i.e. Color(3) ), and by pickle
    if type(value) is cls:
        # For lookups like Color(Color.RED)
        return value
    # by-value search for a matching enum member
    # see if it&#39;s in the reverse mapping (for hashable values)
    try:
        return cls._value2member_map_[value]
    except KeyError:
        # Not found, no need to do long O(n) search
        pass
    except TypeError:
        # not there, now do long search -- O(n) behavior
        for member in cls._member_map_.values():
            if member._value_ == value:
                return member
    # still not found -- verify that members exist, in-case somebody got here mistakenly
    # (such as via super when trying to override __new__)
    if not cls._member_map_:
        raise TypeError(&#34;%r has no members defined&#34; % cls)
    #
    # still not found -- try _missing_ hook
    try:
        exc = None
        result = cls._missing_(value)
    except Exception as e:
        exc = e
        result = None
    try:
        if isinstance(result, cls):
            return result
        elif (
                Flag is not None and issubclass(cls, Flag)
                and cls._boundary_ is EJECT and isinstance(result, int)
            ):
            return result
        else:
            ve_exc = ValueError(&#34;%r is not a valid %s&#34; % (value, cls.__qualname__))
            if result is None and exc is None:
                raise ve_exc
            elif exc is None:
                exc = TypeError(
                        &#39;error in %s._missing_: returned %r instead of None or a valid member&#39;
                        % (cls.__name__, result)
                        )
            if not isinstance(exc, ValueError):
                exc.__context__ = ve_exc
            raise exc
    finally:
        # ensure all variables that could hold an exception are destroyed
        exc = None
        ve_exc = None</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.Visibility._generate_next_value_"><code class="name flex">
<span>def <span class="ident">_generate_next_value_</span></span>(<span>name, start, count, last_values)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the next value when not given.</p>
<p>name: the name of the member
start: the initial start value or None
count: the number of existing members
last_values: the list of values assigned</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _generate_next_value_(name, start, count, last_values):
    &#34;&#34;&#34;
    Generate the next value when not given.

    name: the name of the member
    start: the initial start value or None
    count: the number of existing members
    last_values: the list of values assigned
    &#34;&#34;&#34;
    if not last_values:
        return start
    try:
        last = last_values[-1]
        last_values.sort()
        if last == last_values[-1]:
            # no difference between old and new methods
            return last + 1
        else:
            # trigger old method (with warning)
            raise TypeError
    except TypeError:
        import warnings
        warnings.warn(
                &#34;In 3.13 the default `auto()`/`_generate_next_value_` will require all values to be sortable and support adding +1\n&#34;
                &#34;and the value returned will be the largest value in the enum incremented by 1&#34;,
                DeprecationWarning,
                stacklevel=3,
                )
        for v in reversed(last_values):
            try:
                return v + 1
            except TypeError:
                pass
        return start</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.dtos.Visibility._new_member_"><code class="name flex">
<span>def <span class="ident">_new_member_</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create and return a new object.
See help(type) for accurate signature.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="quetzal.dtos" href="index.html">quetzal.dtos</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="quetzal.dtos.dtos.appendText" href="#quetzal.dtos.dtos.appendText">appendText</a></code></li>
<li><code><a title="quetzal.dtos.dtos.debug" href="#quetzal.dtos.dtos.debug">debug</a></code></li>
<li><code><a title="quetzal.dtos.dtos.getCopyName" href="#quetzal.dtos.dtos.getCopyName">getCopyName</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="quetzal.dtos.dtos.AccessMode" href="#quetzal.dtos.dtos.AccessMode">AccessMode</a></code></h4>
<ul class="">
<li><code><a title="quetzal.dtos.dtos.AccessMode.OTHERS" href="#quetzal.dtos.dtos.AccessMode.OTHERS">OTHERS</a></code></li>
<li><code><a title="quetzal.dtos.dtos.AccessMode.OWNER" href="#quetzal.dtos.dtos.AccessMode.OWNER">OWNER</a></code></li>
<li><code><a title="quetzal.dtos.dtos.AccessMode.__new__" href="#quetzal.dtos.dtos.AccessMode.__new__">__new__</a></code></li>
<li><code><a title="quetzal.dtos.dtos.AccessMode._generate_next_value_" href="#quetzal.dtos.dtos.AccessMode._generate_next_value_">_generate_next_value_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.AccessMode._member_map_" href="#quetzal.dtos.dtos.AccessMode._member_map_">_member_map_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.AccessMode._member_names_" href="#quetzal.dtos.dtos.AccessMode._member_names_">_member_names_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.AccessMode._member_type_" href="#quetzal.dtos.dtos.AccessMode._member_type_">_member_type_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.AccessMode._new_member_" href="#quetzal.dtos.dtos.AccessMode._new_member_">_new_member_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.AccessMode._unhashable_values_" href="#quetzal.dtos.dtos.AccessMode._unhashable_values_">_unhashable_values_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.AccessMode._use_args_" href="#quetzal.dtos.dtos.AccessMode._use_args_">_use_args_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.AccessMode._value2member_map_" href="#quetzal.dtos.dtos.AccessMode._value2member_map_">_value2member_map_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.AccessMode._value_repr_" href="#quetzal.dtos.dtos.AccessMode._value_repr_">_value_repr_</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="quetzal.dtos.dtos.Action" href="#quetzal.dtos.dtos.Action">Action</a></code></h4>
<ul class="">
<li><code><a title="quetzal.dtos.dtos.Action.ANALYZE" href="#quetzal.dtos.dtos.Action.ANALYZE">ANALYZE</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Action.COPY" href="#quetzal.dtos.dtos.Action.COPY">COPY</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Action.DELETE" href="#quetzal.dtos.dtos.Action.DELETE">DELETE</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Action.DOWNLOAD" href="#quetzal.dtos.dtos.Action.DOWNLOAD">DOWNLOAD</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Action.EDIT" href="#quetzal.dtos.dtos.Action.EDIT">EDIT</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Action.MOVE" href="#quetzal.dtos.dtos.Action.MOVE">MOVE</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Action.NEW_DIR" href="#quetzal.dtos.dtos.Action.NEW_DIR">NEW_DIR</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Action.RENAME" href="#quetzal.dtos.dtos.Action.RENAME">RENAME</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Action.SHARE" href="#quetzal.dtos.dtos.Action.SHARE">SHARE</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Action.UPLOAD_FILE" href="#quetzal.dtos.dtos.Action.UPLOAD_FILE">UPLOAD_FILE</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Action.__new__" href="#quetzal.dtos.dtos.Action.__new__">__new__</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Action._generate_next_value_" href="#quetzal.dtos.dtos.Action._generate_next_value_">_generate_next_value_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Action._member_map_" href="#quetzal.dtos.dtos.Action._member_map_">_member_map_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Action._member_names_" href="#quetzal.dtos.dtos.Action._member_names_">_member_names_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Action._member_type_" href="#quetzal.dtos.dtos.Action._member_type_">_member_type_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Action._new_member_" href="#quetzal.dtos.dtos.Action._new_member_">_new_member_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Action._unhashable_values_" href="#quetzal.dtos.dtos.Action._unhashable_values_">_unhashable_values_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Action._use_args_" href="#quetzal.dtos.dtos.Action._use_args_">_use_args_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Action._value2member_map_" href="#quetzal.dtos.dtos.Action._value2member_map_">_value2member_map_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Action._value_repr_" href="#quetzal.dtos.dtos.Action._value_repr_">_value_repr_</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="quetzal.dtos.dtos.AnalysisProgress" href="#quetzal.dtos.dtos.AnalysisProgress">AnalysisProgress</a></code></h4>
<ul class="">
<li><code><a title="quetzal.dtos.dtos.AnalysisProgress.FULL" href="#quetzal.dtos.dtos.AnalysisProgress.FULL">FULL</a></code></li>
<li><code><a title="quetzal.dtos.dtos.AnalysisProgress.HALF" href="#quetzal.dtos.dtos.AnalysisProgress.HALF">HALF</a></code></li>
<li><code><a title="quetzal.dtos.dtos.AnalysisProgress.NONE" href="#quetzal.dtos.dtos.AnalysisProgress.NONE">NONE</a></code></li>
<li><code><a title="quetzal.dtos.dtos.AnalysisProgress.__eq__" href="#quetzal.dtos.dtos.AnalysisProgress.__eq__">__eq__</a></code></li>
<li><code><a title="quetzal.dtos.dtos.AnalysisProgress.__ge__" href="#quetzal.dtos.dtos.AnalysisProgress.__ge__">__ge__</a></code></li>
<li><code><a title="quetzal.dtos.dtos.AnalysisProgress.__gt__" href="#quetzal.dtos.dtos.AnalysisProgress.__gt__">__gt__</a></code></li>
<li><code><a title="quetzal.dtos.dtos.AnalysisProgress.__hash__" href="#quetzal.dtos.dtos.AnalysisProgress.__hash__">__hash__</a></code></li>
<li><code><a title="quetzal.dtos.dtos.AnalysisProgress.__le__" href="#quetzal.dtos.dtos.AnalysisProgress.__le__">__le__</a></code></li>
<li><code><a title="quetzal.dtos.dtos.AnalysisProgress.__lt__" href="#quetzal.dtos.dtos.AnalysisProgress.__lt__">__lt__</a></code></li>
<li><code><a title="quetzal.dtos.dtos.AnalysisProgress.__new__" href="#quetzal.dtos.dtos.AnalysisProgress.__new__">__new__</a></code></li>
<li><code><a title="quetzal.dtos.dtos.AnalysisProgress._generate_next_value_" href="#quetzal.dtos.dtos.AnalysisProgress._generate_next_value_">_generate_next_value_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.AnalysisProgress._member_map_" href="#quetzal.dtos.dtos.AnalysisProgress._member_map_">_member_map_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.AnalysisProgress._member_names_" href="#quetzal.dtos.dtos.AnalysisProgress._member_names_">_member_names_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.AnalysisProgress._member_type_" href="#quetzal.dtos.dtos.AnalysisProgress._member_type_">_member_type_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.AnalysisProgress._new_member_" href="#quetzal.dtos.dtos.AnalysisProgress._new_member_">_new_member_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.AnalysisProgress._unhashable_values_" href="#quetzal.dtos.dtos.AnalysisProgress._unhashable_values_">_unhashable_values_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.AnalysisProgress._use_args_" href="#quetzal.dtos.dtos.AnalysisProgress._use_args_">_use_args_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.AnalysisProgress._value2member_map_" href="#quetzal.dtos.dtos.AnalysisProgress._value2member_map_">_value2member_map_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.AnalysisProgress._value_repr_" href="#quetzal.dtos.dtos.AnalysisProgress._value_repr_">_value_repr_</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="quetzal.dtos.dtos.FileType" href="#quetzal.dtos.dtos.FileType">FileType</a></code></h4>
<ul class="">
<li><code><a title="quetzal.dtos.dtos.FileType.DIRECTORY" href="#quetzal.dtos.dtos.FileType.DIRECTORY">DIRECTORY</a></code></li>
<li><code><a title="quetzal.dtos.dtos.FileType.FILE" href="#quetzal.dtos.dtos.FileType.FILE">FILE</a></code></li>
<li><code><a title="quetzal.dtos.dtos.FileType.__new__" href="#quetzal.dtos.dtos.FileType.__new__">__new__</a></code></li>
<li><code><a title="quetzal.dtos.dtos.FileType._generate_next_value_" href="#quetzal.dtos.dtos.FileType._generate_next_value_">_generate_next_value_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.FileType._member_map_" href="#quetzal.dtos.dtos.FileType._member_map_">_member_map_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.FileType._member_names_" href="#quetzal.dtos.dtos.FileType._member_names_">_member_names_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.FileType._member_type_" href="#quetzal.dtos.dtos.FileType._member_type_">_member_type_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.FileType._new_member_" href="#quetzal.dtos.dtos.FileType._new_member_">_new_member_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.FileType._unhashable_values_" href="#quetzal.dtos.dtos.FileType._unhashable_values_">_unhashable_values_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.FileType._use_args_" href="#quetzal.dtos.dtos.FileType._use_args_">_use_args_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.FileType._value2member_map_" href="#quetzal.dtos.dtos.FileType._value2member_map_">_value2member_map_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.FileType._value_repr_" href="#quetzal.dtos.dtos.FileType._value_repr_">_value_repr_</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="quetzal.dtos.dtos.Permission" href="#quetzal.dtos.dtos.Permission">Permission</a></code></h4>
<ul class="">
<li><code><a title="quetzal.dtos.dtos.Permission.FULL_WRITE" href="#quetzal.dtos.dtos.Permission.FULL_WRITE">FULL_WRITE</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Permission.POST_ONLY" href="#quetzal.dtos.dtos.Permission.POST_ONLY">POST_ONLY</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Permission.READ_ONLY" href="#quetzal.dtos.dtos.Permission.READ_ONLY">READ_ONLY</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Permission.__new__" href="#quetzal.dtos.dtos.Permission.__new__">__new__</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Permission._generate_next_value_" href="#quetzal.dtos.dtos.Permission._generate_next_value_">_generate_next_value_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Permission._member_map_" href="#quetzal.dtos.dtos.Permission._member_map_">_member_map_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Permission._member_names_" href="#quetzal.dtos.dtos.Permission._member_names_">_member_names_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Permission._member_type_" href="#quetzal.dtos.dtos.Permission._member_type_">_member_type_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Permission._new_member_" href="#quetzal.dtos.dtos.Permission._new_member_">_new_member_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Permission._unhashable_values_" href="#quetzal.dtos.dtos.Permission._unhashable_values_">_unhashable_values_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Permission._use_args_" href="#quetzal.dtos.dtos.Permission._use_args_">_use_args_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Permission._value2member_map_" href="#quetzal.dtos.dtos.Permission._value2member_map_">_value2member_map_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Permission._value_repr_" href="#quetzal.dtos.dtos.Permission._value_repr_">_value_repr_</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="quetzal.dtos.dtos.QuetzalFile" href="#quetzal.dtos.dtos.QuetzalFile">QuetzalFile</a></code></h4>
<ul class="">
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.FILE_DEFAULT_DESCRIPTION" href="#quetzal.dtos.dtos.QuetzalFile.FILE_DEFAULT_DESCRIPTION">FILE_DEFAULT_DESCRIPTION</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.FILE_DEFAULT_META" href="#quetzal.dtos.dtos.QuetzalFile.FILE_DEFAULT_META">FILE_DEFAULT_META</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.PROJECT_DEFAULT_DESCRIPTION" href="#quetzal.dtos.dtos.QuetzalFile.PROJECT_DEFAULT_DESCRIPTION">PROJECT_DEFAULT_DESCRIPTION</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.PROJECT_DEFAULT_META" href="#quetzal.dtos.dtos.QuetzalFile.PROJECT_DEFAULT_META">PROJECT_DEFAULT_META</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.ROOT_DESCRIPTOIN" href="#quetzal.dtos.dtos.QuetzalFile.ROOT_DESCRIPTOIN">ROOT_DESCRIPTOIN</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.ROOT_META" href="#quetzal.dtos.dtos.QuetzalFile.ROOT_META">ROOT_META</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.USER_ROOT_DESCRIPTION" href="#quetzal.dtos.dtos.QuetzalFile.USER_ROOT_DESCRIPTION">USER_ROOT_DESCRIPTION</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.USER_ROOT_META" href="#quetzal.dtos.dtos.QuetzalFile.USER_ROOT_META">USER_ROOT_META</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.__eq__" href="#quetzal.dtos.dtos.QuetzalFile.__eq__">__eq__</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.__format__" href="#quetzal.dtos.dtos.QuetzalFile.__format__">__format__</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.__hash__" href="#quetzal.dtos.dtos.QuetzalFile.__hash__">__hash__</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.__init__" href="#quetzal.dtos.dtos.QuetzalFile.__init__">__init__</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.__repr__" href="#quetzal.dtos.dtos.QuetzalFile.__repr__">__repr__</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._abs_path" href="#quetzal.dtos.dtos.QuetzalFile._abs_path">_abs_path</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._analyze" href="#quetzal.dtos.dtos.QuetzalFile._analyze">_analyze</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._copy" href="#quetzal.dtos.dtos.QuetzalFile._copy">_copy</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._delete" href="#quetzal.dtos.dtos.QuetzalFile._delete">_delete</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._editDescription" href="#quetzal.dtos.dtos.QuetzalFile._editDescription">_editDescription</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._getDescriptionPath" href="#quetzal.dtos.dtos.QuetzalFile._getDescriptionPath">_getDescriptionPath</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._getMetaDataPath" href="#quetzal.dtos.dtos.QuetzalFile._getMetaDataPath">_getMetaDataPath</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._instantiateFile" href="#quetzal.dtos.dtos.QuetzalFile._instantiateFile">_instantiateFile</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._loadMetaData" href="#quetzal.dtos.dtos.QuetzalFile._loadMetaData">_loadMetaData</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._makeDefaultDescription" href="#quetzal.dtos.dtos.QuetzalFile._makeDefaultDescription">_makeDefaultDescription</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._move" href="#quetzal.dtos.dtos.QuetzalFile._move">_move</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._newDirectory" href="#quetzal.dtos.dtos.QuetzalFile._newDirectory">_newDirectory</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._parseMetadata" href="#quetzal.dtos.dtos.QuetzalFile._parseMetadata">_parseMetadata</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._rename" href="#quetzal.dtos.dtos.QuetzalFile._rename">_rename</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._share" href="#quetzal.dtos.dtos.QuetzalFile._share">_share</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._syncAnalysisState" href="#quetzal.dtos.dtos.QuetzalFile._syncAnalysisState">_syncAnalysisState</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._updateMetaForAnalyze" href="#quetzal.dtos.dtos.QuetzalFile._updateMetaForAnalyze">_updateMetaForAnalyze</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._updateMetaForCopy" href="#quetzal.dtos.dtos.QuetzalFile._updateMetaForCopy">_updateMetaForCopy</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._updateMetaForDelete" href="#quetzal.dtos.dtos.QuetzalFile._updateMetaForDelete">_updateMetaForDelete</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._updateMetaForMove" href="#quetzal.dtos.dtos.QuetzalFile._updateMetaForMove">_updateMetaForMove</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._updateMetaForNewFile" href="#quetzal.dtos.dtos.QuetzalFile._updateMetaForNewFile">_updateMetaForNewFile</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._updateMetaForRename" href="#quetzal.dtos.dtos.QuetzalFile._updateMetaForRename">_updateMetaForRename</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._updateMetaForShare" href="#quetzal.dtos.dtos.QuetzalFile._updateMetaForShare">_updateMetaForShare</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._upload" href="#quetzal.dtos.dtos.QuetzalFile._upload">_upload</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.analysis_progress" href="#quetzal.dtos.dtos.QuetzalFile.analysis_progress">analysis_progress</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.createdBy" href="#quetzal.dtos.dtos.QuetzalFile.createdBy">createdBy</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.fromFile" href="#quetzal.dtos.dtos.QuetzalFile.fromFile">fromFile</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.full_path" href="#quetzal.dtos.dtos.QuetzalFile.full_path">full_path</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.getDescription" href="#quetzal.dtos.dtos.QuetzalFile.getDescription">getDescription</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.getDescriptionPath" href="#quetzal.dtos.dtos.QuetzalFile.getDescriptionPath">getDescriptionPath</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.getMetaDataPath" href="#quetzal.dtos.dtos.QuetzalFile.getMetaDataPath">getMetaDataPath</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.home" href="#quetzal.dtos.dtos.QuetzalFile.home">home</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.iterdir" href="#quetzal.dtos.dtos.QuetzalFile.iterdir">iterdir</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.loadMetaData" href="#quetzal.dtos.dtos.QuetzalFile.loadMetaData">loadMetaData</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.mode" href="#quetzal.dtos.dtos.QuetzalFile.mode">mode</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.name" href="#quetzal.dtos.dtos.QuetzalFile.name">name</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.path" href="#quetzal.dtos.dtos.QuetzalFile.path">path</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.perform" href="#quetzal.dtos.dtos.QuetzalFile.perform">perform</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.permission" href="#quetzal.dtos.dtos.QuetzalFile.permission">permission</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.type" href="#quetzal.dtos.dtos.QuetzalFile.type">type</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.user" href="#quetzal.dtos.dtos.QuetzalFile.user">user</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.visibility" href="#quetzal.dtos.dtos.QuetzalFile.visibility">visibility</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="quetzal.dtos.dtos.User" href="#quetzal.dtos.dtos.User">User</a></code></h4>
<ul class="two-column">
<li><code><a title="quetzal.dtos.dtos.User.GuestId" href="#quetzal.dtos.dtos.User.GuestId">GuestId</a></code></li>
<li><code><a title="quetzal.dtos.dtos.User.__eq__" href="#quetzal.dtos.dtos.User.__eq__">__eq__</a></code></li>
<li><code><a title="quetzal.dtos.dtos.User.__hash__" href="#quetzal.dtos.dtos.User.__hash__">__hash__</a></code></li>
<li><code><a title="quetzal.dtos.dtos.User.__init__" href="#quetzal.dtos.dtos.User.__init__">__init__</a></code></li>
<li><code><a title="quetzal.dtos.dtos.User.__repr__" href="#quetzal.dtos.dtos.User.__repr__">__repr__</a></code></li>
<li><code><a title="quetzal.dtos.dtos.User.id" href="#quetzal.dtos.dtos.User.id">id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="quetzal.dtos.dtos.Visibility" href="#quetzal.dtos.dtos.Visibility">Visibility</a></code></h4>
<ul class="">
<li><code><a title="quetzal.dtos.dtos.Visibility.PRIVATE" href="#quetzal.dtos.dtos.Visibility.PRIVATE">PRIVATE</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Visibility.SHARED" href="#quetzal.dtos.dtos.Visibility.SHARED">SHARED</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Visibility.__new__" href="#quetzal.dtos.dtos.Visibility.__new__">__new__</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Visibility._generate_next_value_" href="#quetzal.dtos.dtos.Visibility._generate_next_value_">_generate_next_value_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Visibility._member_map_" href="#quetzal.dtos.dtos.Visibility._member_map_">_member_map_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Visibility._member_names_" href="#quetzal.dtos.dtos.Visibility._member_names_">_member_names_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Visibility._member_type_" href="#quetzal.dtos.dtos.Visibility._member_type_">_member_type_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Visibility._new_member_" href="#quetzal.dtos.dtos.Visibility._new_member_">_new_member_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Visibility._unhashable_values_" href="#quetzal.dtos.dtos.Visibility._unhashable_values_">_unhashable_values_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Visibility._use_args_" href="#quetzal.dtos.dtos.Visibility._use_args_">_use_args_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Visibility._value2member_map_" href="#quetzal.dtos.dtos.Visibility._value2member_map_">_value2member_map_</a></code></li>
<li><code><a title="quetzal.dtos.dtos.Visibility._value_repr_" href="#quetzal.dtos.dtos.Visibility._value_repr_">_value_repr_</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>